<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nodejs之实现一个模版引擎]]></title>
    <url>%2F2020%2F04%2F14%2Fnode-template%2F</url>
    <content type="text"><![CDATA[前言最近看完了朴大的 《深入浅出nodejs》 这本书，在里面学到了许多，也推荐大家可以去看一下，看完感觉可以写几篇文章记录总结一下，提升一下印象，毕竟学到的东西感觉不记下来过不久就容易忘记，大家也要养成学习记录的习惯，方便以后重温，今天来实现一个 node 的模版引擎，当然这个模版引擎在前端也可以用。 借鉴ejs标签标签借鉴 ejs，用过的同学肯定知道，例如使用 &lt;%= name %&gt; 这种标签来展示数据，使用 &lt;% if(name){ %&gt; 这种标签来做 js 操作，如 if 判断/ for循环，比如下面12345&lt;% if (name) &#123; %&gt; &lt;h1&gt;&lt;%=name%&gt;&lt;/h1&gt;&lt;% &#125; else &#123; %&gt; &lt;h1&gt;请登陆&lt;/h1&gt;&lt;% &#125; %&gt; 渲染方法我们先来看个简单的渲染1let str = 'hello &lt;%=name%&gt;' 假如我们的有一个字段 name = &#39;wunci&#39;;12345const name = 'wunci';let str = 'hello &lt;%=name%&gt;';str.replace(/&lt;%=([\S\s]+?)%&gt;/g, function(match,value)&#123; return name&#125;) 结果1hello wunci 按照这个思路就很简单了，我们先来思考🤔一个问题，数据渲染简单，直接替换就可以来了，那么 js 的逻辑判断这种怎么处理呢，我们拿到的都是字符串，这里需要借助 Function 来实现，具体渲染成如下样式123456let tpl = '';if (name)&#123; tpl += '&lt;h1&gt;' + name ' +&lt;/h1&gt;'&#125;else&#123; tpl += '&lt;h1&gt;请登陆&lt;/h1&gt;'&#125; 然后使用 new Function ,123const complied = new Function('name',tpl); const result = complied()console.log(result) 直接上代码12345678910111213141516171819202122const render = function(str, data) &#123; str = str .replace(/\n/g, "") .replace(/\s&#123;2,&#125;/g, "") .replace(/&lt;%=([\S\s]+?)%&gt;/g, function(match, val) &#123; return `'+ $&#123;val&#125; +'`; &#125;) .replace(/&lt;%([\S\s]+?)%&gt;/g, function(match, val) &#123; return `';\n$&#123;val&#125;\ntpl +='`; &#125;); str = `let tpl = '$&#123;str&#125;';return tpl;`; str = `with(option)&#123;$&#123;str&#125;;return tpl;&#125;`; const complied = new Function("option", str); let result; try &#123; result = complied(data); &#125; catch (error) &#123; console.log(error); &#125; return result;&#125;; 看着整个代码感觉没什么，等等，with 是什么？知道的同学可以忽略后面的，with 的作用就是通常我们取数据都是 let people = obj.name +&#39;-&#39;+ obj.age 这样，每次都需要拿 obj，为了简化我们可以这样写：12345const obj = &#123;name:'wunci', age: 26&#125;let peoplewith(obj)&#123; people = name +'-'+ age&#125; 但是不推荐用 with，容易引起作用域混乱，但是我看 Vue 源码也用到了，还是谨慎一点。比如如下：123with (obj) &#123; foo = bar;&#125; 它的结果有可能是如下四种之一: obj.foo = obj.bar;、obj.foo = bar;、foo = bar;、foo = obj.bar;，这些结果取决于它的作用域。如果作用域链上没有导致冲突的变量存在，使用它则是 安全的。但在多人合作的项目中，这并不容易保证，所以要慎用 with xss攻击我们需要时刻关注安全，在上面的模版上，如果 name 是 &lt;script&gt;alert(&#39;xss攻击&#39;)&lt;/script&gt;，那么我们渲染到页面上100%会显示一个弹窗，很危险。因此我们需要对尖括号进行转义，我们单独写一个方法处理 12345678const escape = function(html) &#123; return String(html) .replace(/&amp;(?!\w+;)/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); // IE下不支持&amp;apos;(单引号)转义 &#125;; 当然，并不是所有的都需要转义，比如我就是想让他输出有格式的标签 &lt;h1&gt;h1&lt;/h1&gt;，所以我们需要提供两种不同的标签，ejs 就提供了,如下123456&lt;%= name %&gt; 会转义&lt;%- name %&gt; 原始输出如果输入&lt;h1&gt;h1&lt;/h1&gt;，他们的对应结果是&lt;%= name %&gt; &lt;h1&gt;h1&lt;/h1&gt;&lt;%- name %&gt; 有格式的 h1 然后完善一下123456789101112131415161718192021222324252627282930313233const render = function(str, data) &#123;+ const escape = function(html) &#123;+ return String(html)+ .replace(/&amp;(?!\w+;)/g, "&amp;amp;")+ .replace(/&lt;/g, "&amp;lt;")+ .replace(/&gt;/g, "&amp;gt;")+ .replace(/"/g, "&amp;quot;")+ .replace(/'/g, "&amp;#039;"); // IE下不支持&amp;apos;(单引号)转义+ &#125;; str = str .replace(/\n/g, "") .replace(/\s&#123;2,&#125;/g, "") .replace(/&lt;%-([\S\s]+?)%&gt;/g, function(match, val) &#123; return `'+ $&#123;val&#125; +'`; &#125;)+ .replace(/&lt;%=([\S\s]+?)%&gt;/g, function(match, val) &#123;+ return `'+ escape($&#123;val&#125;) +'`;+ &#125;) .replace(/&lt;%([\S\s]+?)%&gt;/g, function(match, val) &#123; return `';\n$&#123;val&#125;\ntpl +='`; &#125;); str = `let tpl = '$&#123;str&#125;';return tpl;`; str = `with(option)&#123;$&#123;str&#125;;return tpl;&#125;`; const complied = new Function("option", str); let result; try &#123; result = complied(data); &#125; catch (error) &#123; console.log(error); &#125; return result;&#125;; 测试123456const str = ` &lt;% for (var i = 0; i &lt; users.length; i++) &#123; %&gt; &lt;% var item = users[i];%&gt; &lt;p&gt;&lt;%= (i+1) %&gt;、&lt;%-item.name%&gt;&lt;/p&gt; &lt;% &#125; %&gt;`;const result = render(str, &#123;users: [&#123; name: "wunci" &#125;, &#123; name: "other" &#125;]&#125;); 结果1&lt;p&gt;1、wunci&lt;/p&gt;&lt;p&gt;2、other&lt;/p&gt; 上面可能不好复制，下面是完整代码123456789101112131415161718192021222324252627282930313233const render = function(str, data) &#123; const escape = function(html) &#123; return String(html) .replace(/&amp;(?!\w+;)/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;") .replace(/"/g, "&amp;quot;") .replace(/'/g, "&amp;#039;"); // IE下不支持&amp;apos;(单引号)转义 &#125;; str = str .replace(/\n/g, "") .replace(/\s&#123;2,&#125;/g, "") .replace(/&lt;%-([\S\s]+?)%&gt;/g, function(match, val) &#123; return `'+ $&#123;val&#125; +'`; &#125;) .replace(/&lt;%=([\S\s]+?)%&gt;/g, function(match, val) &#123; return `'+ escape($&#123;val&#125;) +'`; &#125;) .replace(/&lt;%([\S\s]+?)%&gt;/g, function(match, val) &#123; return `';\n$&#123;val&#125;\ntpl +='`; &#125;); str = `let tpl = '$&#123;str&#125;';return tpl;`; str = `with(option)&#123;$&#123;str&#125;;return tpl;&#125;`; const complied = new Function("option", str); let result; try &#123; result = complied(data); &#125; catch (error) &#123; console.log(error); &#125; return result;&#125;; 使用文件模版我们可以新建一个模版 test.ejs 文件，内容为之前的测试内容1render(fs.readFileSync(`test.ejs`, "utf8") ,&#123;users: [&#123; name: "wunci" &#125;, &#123; name: "other" &#125;]&#125;); 结尾一个模版引擎就完成了，挺简单的，说得有点多了，下一篇带大家实现一个路由和中间件 Reference 深入浅出nodejs 本文地址 Nodejs之实现一个模版引擎]]></content>
      <categories>
        <category>Node</category>
        <category>模版引擎</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs之实现代理]]></title>
    <url>%2F2020%2F04%2F04%2Fnode-proxy%2F</url>
    <content type="text"><![CDATA[前言我们上线一个网站，往往需要代理来完成需求，不然的话就只能使用 IP 加端口的方式来访问应用，目前基本上都会使用 Nginx 来完成反向代理，那么我们开发 Node 应用一定需要 Nginx 吗？肯定不是，我们完全可以通过 Node 来做，但是大多是不建议你用 Node 去处理，因为 Nginx 功能更强大，比如负载均衡，本文主要是帮你了解如何通过 Node 实现代理 使用http-proxy最简单的做法是拿已经写好的包直接使用 1$ cnpm i http-proxy 12345678910111213141516171819const proxy = require("http-proxy").createProxyServer(&#123;&#125;);server = require("http").createServer(function(req, res) &#123; const host = req.headers.host; switch (host) &#123; case "your domain": proxy.web(req, res, &#123; target: "http://localhost:8000" &#125;); break; default: res.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); res.end("Welcome to my server!"); &#125;&#125;);console.log("listening on port 80");server.listen(80); 上面👆代码监听 80 端口（如果你的服务器目前使用来 Nginx，暂用80 端口的话，需要先暂停 Nginx 服务），然后我们通过访问域名（前提是域名做好了解析），然后使用 proxy.web方法反向代理到当前服务下的 8000 端口，到此一个简单的服务完成了 原生实现12345678910111213141516171819202122232425262728const http = require("http");const url = require("url");function request(req, res) &#123; const reqUrl = url.parse(req.url); const target = url.parse("http://localhost:3000"); const options = &#123; hostname: target.hostname, port: target.port, path: reqUrl.path, method: req.method, headers: req.headers &#125;; const proxyReq = http.request(options); proxyReq.on("response", proxyRes =&gt; &#123; res.writeHead(proxyRes.statusCode, proxyRes.headers); proxyRes.pipe(res); &#125;); req.pipe(proxyReq);&#125;http .createServer() .on("request", request) .listen(8003); 是不是很简单？通过访问 8003 端口，我们将请求转发到 3000 端口，可以复制当前代码尝试一下，前提是 3000 端口可以正常访问。当访问 8003 端口的时候，内部重新请求我们需要代理的地址，然后通过 pipe 返回转发后的数据 http-proxy源码实现原理源码地址执行 proxy.web1234567function ProxyServer(options) &#123; ... this.web = this.proxyRequest = createRightProxy('web')(options); ...&#125; 源码地址 内部关键代码执行了一下这段，passes 是一个数组方法，包含deleteLength、timeout、XHeaders、stream，关键点在 stream，其他基本是辅助作用，XHeaders 功能是设置 x-forwarded-* 这种 header，不过前提是 option 配置了 xfwd 才行，timeout 是设置超时时间的，deleteLength 只有请求方法是 OPTIONS 和 DELETE 才会执行123456...for(var i=0; i &lt; passes.length; i++) &#123; if(passes[i](req, res, requestOptions, head, this, cbl)) &#123; // passes can return a truthy value to halt the loop break; &#125;&#125; 源码地址stream 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596module.exports = &#123; deleteLength: ...., timeout: ..., XHeaders: ..., stream: function stream(req, res, options, _, server, clb) &#123; // And we begin! server.emit('start', req, res, options.target || options.forward); var agents = options.followRedirects ? followRedirects : nativeAgents; var http = agents.http; var https = agents.https; if(options.forward) &#123; // If forward enable, so just pipe the request var forwardReq = (options.forward.protocol === 'https:' ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req, 'forward') ); // error handler (e.g. ECONNRESET, ECONNREFUSED) // Handle errors on incoming request as well as it makes sense to var forwardError = createErrorHandler(forwardReq, options.forward); req.on('error', forwardError); forwardReq.on('error', forwardError); (options.buffer || req).pipe(forwardReq); if(!options.target) &#123; return res.end(); &#125; &#125; // Request initalization var proxyReq = (options.target.protocol === 'https:' ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req) ); // Enable developers to modify the proxyReq before headers are sent proxyReq.on('socket', function(socket) &#123; if(server) &#123; server.emit('proxyReq', proxyReq, req, res, options); &#125; &#125;); // allow outgoing socket to timeout so that we could // show an error page at the initial request if(options.proxyTimeout) &#123; proxyReq.setTimeout(options.proxyTimeout, function() &#123; proxyReq.abort(); &#125;); &#125; // Ensure we abort proxy if request is aborted req.on('aborted', function () &#123; proxyReq.abort(); &#125;); // handle errors in proxy and incoming request, just like for forward proxy var proxyError = createErrorHandler(proxyReq, options.target); req.on('error', proxyError); proxyReq.on('error', proxyError); function createErrorHandler(proxyReq, url) &#123; return function proxyError(err) &#123; if (req.socket.destroyed &amp;&amp; err.code === 'ECONNRESET') &#123; server.emit('econnreset', err, req, res, url); return proxyReq.abort(); &#125; if (clb) &#123; clb(err, req, res, url); &#125; else &#123; server.emit('error', err, req, res, url); &#125; &#125; &#125; (options.buffer || req).pipe(proxyReq); proxyReq.on('response', function(proxyRes) &#123; if(server) &#123; server.emit('proxyRes', proxyRes, req, res); &#125; if(!res.headersSent &amp;&amp; !options.selfHandleResponse) &#123; for(var i=0; i &lt; web_o.length; i++) &#123; if(web_o[i](req, res, proxyRes, options)) &#123; break; &#125; &#125; &#125; if (!res.finished) &#123; // Allow us to listen when the proxy has completed proxyRes.on('end', function () &#123; if (server) server.emit('end', req, res, proxyRes); &#125;); // We pipe to the response unless its expected to be handled by the user if (!options.selfHandleResponse) proxyRes.pipe(res); &#125; else &#123; if (server) server.emit('end', req, res, proxyRes); &#125; &#125;); &#125;&#125; 关键代码12345678910111213141516// Request initalizationvar proxyReq = (options.target.protocol === 'https:' ? https : http).request( common.setupOutgoing(options.ssl || &#123;&#125;, options, req));(options.buffer || req).pipe(proxyReq);proxyReq.on('response', function(proxyRes) &#123; if(!res.headersSent &amp;&amp; !options.selfHandleResponse) &#123; for(var i=0; i &lt; web_o.length; i++) &#123; if(web_o[i](req, res, proxyRes, options)) &#123; break; &#125; &#125; &#125; if (!res.finished) &#123; // We pipe to the response unless its expected to be handled by the user if (!options.selfHandleResponse) proxyRes.pipe(res); &#125; &#125;); 实现大致和我们之前写得差不多，但是他考虑得更多，支持 https，错误处理也做得很好，已经很成熟了 结尾至此就基本讲完了，本文意在实操，理论讲解涉及极少，在写一个功能的时候，还是要多了解一下内部的原理知识，能帮助你更好的理解，如果错误还望指正。 本文地址 Nodejs之实现代理]]></content>
      <categories>
        <category>Node</category>
        <category>代理</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码之nextTick]]></title>
    <url>%2F2020%2F03%2F25%2Fvue-sourse-code-nextTick%2F</url>
    <content type="text"><![CDATA[前言今天我们开始讲一下 Vue 的 nextTick 方法的实现，无论是源码还是开发的过程中，经常需要使用到 nextTick，Vue 在更新 DOM 时是异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 源码https://github.com/wunci/vue/blob/dev/src/core/util/next-tick.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485export let isUsingMicroTask = false// 储存回调const callbacks = []// 是否正在处理中let pending = false// 批量执行回调function flushCallbacks () &#123; // 恢复状态以便后续能正常使用 pending = false const copies = callbacks.slice(0) // 执行之前先把回调清空，以便后续能正常调用 callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125;&#125;let timerFunc// 判断是否支持Promise，使用Promise的异步，属于微任务if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true // 判断是否支持MutationObserver，属于微任务&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // iOS 7.x 平台处理的判断 MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true // 是否支持setImmediate，属于宏任务&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // 都不支持就直接使用宏任务 setTimeout timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;// nextTick方法export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 收集回调函数 callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; // 如果没有传递回调函数会执行_resolve，执行的代码其实就是callback this.$nextTick().then(callback) _resolve(ctx) &#125; &#125;) // 如果状态没有正在处理执行 if (!pending) &#123; // 置为处理中 pending = true // 执行刚刚一系列判断下来获得的函数，最终会执行flushCallbacks方法 timerFunc() &#125; // 如果没有传递回调函数就会返回一个Promise，this.$nextTick().then(callback)，执行 _resolve(ctx) 之后会执行callback if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; 我们可以看到 Vue 会借助 timerFunc 方法异步批量处理回调函数，timerFunc 可能是 Promise.then、MutationObserver 、 setImmediate、setTimeout。判断他们的支持程度，降级处理。如果没有传递回调函数会返回一个Promise，并把 resolve 方法赋值给 _resolve，这样我们 this.$nextTick().then(callback)，callback就会被触发了。至于为什么要使用 timerFunc 这种方式，开头已经讲了，是因为 Vue 是异步更新队列，这样做的好处是去除重复数据对于避免不必要的计算和 DOM 操作，比如我们操作一个数据，并且重复多次给他赋不一样的值，this.a = 1;this.a = 2; this.a = 3，答案结果最后自然是3，但是 Vue 不会去更新三次 DOM 或者数据，这样会造成不必要的浪费，所以需要做异步处理去 update 他们，既然更新是异步的，我们如果想直接马上获取最新的数据自然是不行的，需要借助 nextTick，在下一次事件循环中去获取，可以看下面👇的代码 实际代码我们看下面的代码1&lt;div id="app" @click="fn"&gt;&#123;&#123;code&#125;&#125;&lt;/div&gt; 123456789101112131415var vm = new Vue(&#123; el: '#app', data: &#123; code: 0 &#125;, methods:&#123; fn()&#123; this.code = 1 console.log(this.$el.textConent); // 0 this.$nextTick(()=&gt;&#123; console.log(this.$el.textConent) // 1 &#125;) &#125; &#125;&#125;) 你也可以这样 1234567891011121314151617var vm = new Vue(&#123; el: '#app', data: &#123; code: 0 &#125;, methods:&#123; async fn()&#123; this.code = 1 console.log(this.$el.textConent); // 0- this.$nextTick(()=&gt;&#123;- console.log(this.$el.textConent) // 1- &#125;)+ await this.$nextTick()+ console.log(this.$el.textConent) // 1 &#125; &#125;&#125;) 总结今天带大家了解了一下 nextTick 的内部实现，虽然你也可以直接使用 setTimeout 去做，但是基于性能和执行顺序的问题(微任务执行快于宏任务)，推荐还是使用 nextTick 更好一点。 本文地址 Vue源码之nextTick]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[撸一个简易Virtual DOM]]></title>
    <url>%2F2020%2F03%2F19%2Fsimple-virtual-dom%2F</url>
    <content type="text"><![CDATA[前言上一篇我们讲了一下 Vue 的 虚拟DOM，从创建到更新整个流程。今天带大家撸一个简易的虚拟DOM，本文的大部分借鉴 Vue 源码 浏览器渲染流程 摘自浏览器工作原理与实践 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。 准备首先我们要明白什么是虚拟DOM，为什么要用到它，虚拟DOM 是使用 javascript 对象来描述 DOM 树，一切的更新修改都是在更改这个对象，然后反应到真实的 DOM 下。要说为什么要用到它，肯定是因为性能好，因为直接操作 DOM 的代价是很大的，比如，一次操作中有 10 次更新 DOM 的动作，虚拟DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存到本地一个 js 对象中，最终将这个 js 对象一次性 反应到 DOM 树上，再进行后续操作，避免大量无谓的计算。也有人反驳说，使用 虚拟DOM 比起操作真实 DOM 要慢，的确如此，使用 虚拟DOM 确实没有原生操作快，但是既然使用了框架，优化框架都会帮你做，你不用自己去手动做DOM的优化，不用处处去考虑操作 DOM 带来的性能问题，使用 虚拟DOM 可以让性能得到有力的保证。 可以参考知乎问题 网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ 实现使用js对象模拟DOM树这里我们不使用 Vue 的那种根据 template 生成 虚拟DOM 的方法，那样太复杂了，这里只讲简单的方法，我们直接使用 js 对象来描述 DOM 比如如下 的html 代码12345678&lt;div id="app"&gt; &lt;h1 data-title="header"&gt;Virtual Dom&lt;/h1&gt; &lt;ul class="ul1"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 使用 js 对象表示123456789101112131415161718192021222324252627function vnode(tag, data, children) &#123; return &#123; tag, data, children, &#125;;&#125;function createElement(vNode) &#123; let el; if (vNode.tag === 'textNode') &#123; el = document.createTextNode(vNode.children[0]); &#125; else &#123; el = document.createElement(vNode.tag); for (const key in vNode.data) &#123; if (vNode.data.hasOwnProperty(key)) &#123; el.setAttribute(key, vNode.data[key]); &#125; &#125; if (Array.isArray(vNode.children) &amp;&amp; vNode.children.length &gt; 0) &#123; vNode.children.forEach(val =&gt; &#123; el.appendChild(createElement(val)); &#125;); &#125; &#125; vNode.$el = el; return el;&#125; tag：表示当前元素的标签名，后面会看到有 textNode 的标签名，实际上没有，在这里特指文本节点 data：表示当前元素上的 attribute children：表示当前元素的子元素 createElement：使用该方法渲染到页面上 生成 vNode12345678910const vNode1 = vnode('div', &#123; id: 'app' &#125;, [ vnode('h1', &#123; 'data-title': 'header' &#125;, [ vnode('textNode', &#123;&#125;, ['Virtual Dom']), ]), vnode('ul', &#123; class: 'ul1' &#125;, [ vnode('li', &#123;&#125;, [vnode('textNode', &#123;&#125;, ['1'])]), vnode('li', &#123;&#125;, [vnode('textNode', &#123;&#125;, ['2'])]), vnode('li', &#123;&#125;, [vnode('textNode', &#123;&#125;, ['3'])]), ]),]); 反应到页面上，把结果放到 body 下1document.body.appendChild(createElement(vNode1)) 效果 更新Virtual Dom更新之前我们把之前的旧的虚拟DOM li列表上的 key值加上 oldVNode12345678910const vNode1 = vnode('div', &#123; id: 'app' &#125;, [ vnode('h1', &#123; 'data-title': 'header' &#125;, [ vnode('textNode', &#123;&#125;, ['Virtual Dom']), ]), vnode('ul', &#123; class: 'ul1' &#125;, [ vnode('li', &#123;key: 1&#125;, [vnode('textNode', &#123;&#125;, ['1'])]), vnode('li', &#123;key: 2&#125;, [vnode('textNode', &#123;&#125;, ['2'])]), vnode('li', &#123;key: 3&#125;, [vnode('textNode', &#123;&#125;, ['3'])]), ]),]); newVNode1234567891011const vNode2 = vnode('div', &#123; id: 'app' &#125;, [ vnode('h4', &#123; id: 'header'&#125;, [ vnode('textNode', &#123;&#125;, ['元素标签改变了']), ]), vnode('ul', &#123; class: 'ul2' &#125;, [ vnode('li', &#123;key: 5&#125;, [vnode('textNode', &#123;&#125;, ['5'])]), vnode('li', &#123;key: 2&#125;, [vnode('textNode', &#123;&#125;, ['2'])]), vnode('li', &#123;key: 1&#125;, [vnode('textNode', &#123;&#125;, ['1'])]), vnode('li', &#123;key: 4&#125;, [vnode('textNode', &#123;&#125;, ['4'])]), ]),]); 你会发现为把 h1 标签改成了 h4,文本那样也改变了，在 ul 列表里，把他们的顺序改变了，并插入删除了部分元素。当然你也可以定制更复杂的结构 开始 diff，调用 patchVnode 方法1patchVnode(vNode1, vNode2); 12345678910111213141516171819202122232425262728293031323334353637function patchVnode(oldVnode, vnode) &#123; // 1. 文本节点都一样 if (oldVnode.tag === 'textNode' || vnode.tag === 'textNode') &#123; if (oldVnode.children[0] !== vnode.children[0]) &#123; oldVnode.$el.textContent = vnode.children[0]; &#125; return; &#125; // 2. data是否被改变 if (dataChanged(oldVnode.data, vnode.data)) &#123; const oldData = oldVnode.data; const newData = vnode.data; const oldDataKeys = Object.keys(oldData); const newDataKeys = Object.keys(newData); if (oldDataKeys.length === 0) &#123; for (let i = 0; i &lt; oldDataKeys.length; i++) &#123; oldVnode.$el.removeAttribute(oldData[i]); &#125; &#125; else &#123; const filterKeys = new Set([...oldDataKeys, ...newDataKeys]); for (let key of filterKeys) &#123; if (isUndef(newData[key])) &#123; oldVnode.$el.removeAttribute(oldData[key]); &#125; else if (newData[key] !== oldData[key]) &#123; oldVnode.$el.setAttribute(key, newData[key]); &#125; &#125; &#125; &#125; var oldCh = oldVnode.children; var ch = vnode.children; // 如果新旧子节点仍然存在，则继续diff它的子节点 if (oldCh.length || ch.length) &#123; updateChildren(oldVnode.$el, oldCh, ch); &#125;&#125; 上面先对最外层进行比较， 如果是文本，说明已经是当前最后的一个元素了，后面不需要继续执行，发现不一样则改变他们 判断 data 是否变更，如果变更则进行插入或者删除修改操作 继续找它的子元素是否操作，如果存在进行子元素的 diff，使用 updateChildren updateChildren1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465function updateChildren(parentElm, oldCh, newCh) &#123; if (oldCh) var oldStartIdx = 0; var newStartIdx = 0; var oldEndIdx = oldCh.length - 1; var oldStartVnode = oldCh[0]; var oldEndVnode = oldCh[oldEndIdx]; var newEndIdx = newCh.length - 1; var newStartVnode = newCh[0]; var newEndVnode = newCh[newEndIdx]; var oldKeyToIdx, idxInOld, vnodeToMove, refElm; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx]; &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode); parentElm.insertBefore(oldStartVnode.$el, oldEndVnode.$el.nextSibling); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode); parentElm.insertBefore(oldEndVnode.$el, oldStartVnode.$el); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125; idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); if (isUndef(idxInOld)) &#123; parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.$el); &#125; else &#123; vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode); oldCh[idxInOld] = undefined; parentElm.insertBefore(vnodeToMove.$el, oldStartVnode.$el); &#125; else &#123; parentElm.insertBefore( createElement(newStartVnode), oldStartVnode.$el, ); &#125; &#125; newStartVnode = newCh[++newStartIdx]; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; addVnodes(parentElm, newCh, newStartIdx, newEndIdx); &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125;&#125; 上面代码基本参照 Vue 源码的方法，如果你阅读过我之前发的文章，肯定有印象，代码内就不多作解释了，上一篇文章的注释说得很明白，感兴趣可以去翻阅一下。 看一下结果，一切都正常 相关源码已经放在 GitHub: https://github.com/wunci/simple-virtual-dom 总结本文带大家撸了一个 虚拟DOM，代码大部分参照 Vue 的源码改造，并没有过多的去阐述代码内的运行流程，因为上一篇已经大致讲过了，本文意在抛砖引玉，如有问题还望指出 本文地址 撸一个简易Virtual Dom]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码之虚拟DOM]]></title>
    <url>%2F2020%2F03%2F17%2Fvue-source-code-virtual-dom%2F</url>
    <content type="text"><![CDATA[前言上一篇我们讲了一下 Vue 的双向数据绑定原理，今天我们开始讲一下 Vue 的 虚拟DOM。本文会先分析一下 Vue 的 虚拟DOM，然后下一篇文章会带大家撸一个简易的 虚拟DOM Vue虚拟DOM创建虚拟DOMhttps://github.com/wunci/vue/blob/dev/src/core/vdom/vnode.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) &#123; this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = undefined this.context = context this.functionalContext = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next */ get child (): Component | void &#123; return this.componentInstance &#125;&#125; 以上代码是Vue创建 虚拟DOM 的类，一眼看过去是不是感觉东西太多了？其实我们主要关注主要的几个参数就可以了，tag 、data、children、text、elm、key tag 表示当前 vnode 的标签类型，比如 div ul data 表示当前 vnode 标签上的 attribute，可能是class、id、key children 表示当前 vnode 的子节点 text 表示文本内容 elm 表示当前 vnode 的真实 DOM 节点 key diff算法 需要用到，就是我们开发中写的 :key 从入口开始我们从入口开始，看一下 Vue 实现 虚拟DOM 的流程是怎么样的，https://github.com/wunci/vue/blob/dev/src/core/instance/init.js#L1512345678910111213141516171819202122export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; ...... // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') ...... if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 上面这段代码在上一篇文章有讲过，我们在这里只需要关心 vm.$mount(vm.$options.el) 这段代码，从这里开始挂载DOM $mounthttps://github.com/wunci/vue/blob/dev/src/platforms/web/entry-runtime-with-compiler.js#L17 1234567891011121314151617181920212223242526272829303132333435363738394041424344var mount = Vue.prototype.$mount;Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; query(el); /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; warn( "Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead." ); return this &#125; var options = this.$options; // resolve template/el and convert to render function if (!options.render) &#123; ... &#125; else if (el) &#123; template = getOuterHTML(el); &#125; if (template) &#123; var ref = compileToFunctions(template, &#123; outputSourceRange: "development" !== 'production', shouldDecodeNewlines: shouldDecodeNewlines, shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref, delimiters: options.delimiters, comments: options.comments &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; mark('compile end'); measure(("vue " + (this._name) + " compile"), 'compile', 'compile end'); &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125;; 我们先看上面 template 是什么，template 其实是我们写的模版的 html 比如 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，然后把模版给 compileToFunctions 方法去解析，这过程就是生成ast html树。得到 ref 对象，内部有一个render方法，它的方法就是类似下面代码一样,比如 _c 其实就是我们后面要讲的创建生成 vnode 元素方法 1with(this)&#123;return _c('div',&#123;attrs:&#123;"id":"div1"&#125;&#125;,_l((arr),function(item,idx)&#123;return _c('span',&#123;key:item&#125;,[_v(_s(item))])&#125;),0)&#125; 以下就是对应的方法 _v指创建文本vnode12345678910111213141516171819function installRenderHelpers (target) &#123; target._o = markOnce; target._n = toNumber; target._s = toString; target._l = renderList; target._t = renderSlot; target._q = looseEqual; target._i = looseIndexOf; target._m = renderStatic; target._f = resolveFilter; target._k = checkKeyCodes; target._b = bindObjectProps; target._v = createTextVNode; target._e = createEmptyVNode; target._u = resolveScopedSlots; target._g = bindObjectListeners; target._d = bindDynamicKeys; target._p = prependModifier;&#125; 我们接着往下看最后代码会执行 return mount.call(this, el, hydrating)，mount代码就是之前第一行代码提前获取了 https://github.com/wunci/vue/blob/dev/src/platforms/web/runtime/index.js#L371234567Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 上面代码继续调用了 mountComponent 方法，继续往下看 mountComponenthttps://github.com/wunci/vue/blob/dev/src/core/instance/lifecycle.js#L14112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode .... &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; const name = vm._name const id = vm._uid const startTag = `vue-perf-start:$&#123;id&#125;` const endTag = `vue-perf-end:$&#123;id&#125;` mark(startTag) const vnode = vm._render() mark(endTag) measure(`vue $&#123;name&#125; render`, startTag, endTag) mark(startTag) vm._update(vnode, hydrating) mark(endTag) measure(`vue $&#123;name&#125; patch`, startTag, endTag) &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true ) hydrating = false if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 这段代码是重点，看过上一篇文章的可能有印象，主要实例化了一个订阅者Watcher，内部会执行updateComponent方法，内容如下123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; Vue会调用 _render 方法去生成虚拟DOM，调用_update去更新视图，_update方法后面讲diff算法会讲，很重要。不过这里我们先看看_render函数 _renderhttps://github.com/wunci/vue/blob/dev/src/core/instance/render.js#L69123456789101112131415161718192021222324Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options .... vm.$vnode = _parentVnode // render self let vnode try &#123; currentRenderingInstance = vm vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) &#125; finally &#123; currentRenderingInstance = null &#125; ... // set parent vnode.parent = _parentVnode return vnode &#125; 我们主要看这一段代码 vnode = render.call(vm._renderProxy, vm.$createElement)，生成 虚拟DOM，之前会把 vm.$createElement 方法传入，其实就是创建 vnode 元素的方法，最后会执行render方法，render 方法就是我们之前 compileToFunctions 函数生成对象的方法， $createElementhttps://github.com/wunci/vue/blob/dev/src/core/instance/render.js#L3412345export function initRender (vm: Component) &#123; ... vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) ...&#125; 继续调用了createElement方法 createElementhttps://github.com/wunci/vue/blob/dev/src/core/vdom/create-element.js#L28123456789101112131415161718export function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; return _createElement(context, tag, data, children, normalizationType)&#125; 不用多说了？ 继续找_createElement，往下看下面几行代码就是了 _createElementhttps://github.com/wunci/vue/blob/dev/src/core/vdom/create-element.js#L471234567891011121314151617181920212223242526272829303132333435363738394041424344454647export function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; .... if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; ... vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125; 到目前为止创建虚拟DOM的过程就结束了 diff更新虚拟DOM之前我们又说到用_render来生成vnode树，用_update来更新视图 _updatehttps://github.com/wunci/vue/blob/dev/src/core/instance/lifecycle.js#L5912345678910111213141516Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const restoreActiveInstance = setActiveInstance(vm) vm._vnode = vnode // 如果之前不存在虚拟DOM if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // 如果存在旧的虚拟DOM，就传递到__patch__去进行新旧的比较 vm.$el = vm.__patch__(prevVnode, vnode) &#125; .....&#125; 上面第一个参数传递的就是虚拟DOM，也就是本文之前说的 _render() 返回的 vnode ，我们需要继续看 __patch__ 方法 patch12345678910111213141516171819202122return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; ..... let isInitialPatch = false const insertedVnodeQueue = [] // 不存在旧的就会重新创建一个 if (isUndef(oldVnode)) &#123; isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) &#125; else &#123; ..... &#125; &#125; return vnode.elm&#125; patch方法主要做了两件事情，如果没有旧的 虚拟DOM，旧会重新创建一个根节点。否则的话使用sameVnode判断 oldVnode和vnode是否是相同的节点(这个相同不是完全都相同)，sameVnode的作用主要是判断是否只需要作局部刷新，来看看具体的代码12345678910111213141516function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 主要判断key tag，如果 key 并且 tag 相同我们旧可以判定作局部刷新，如果不相同那么就会直接跳过 diff，进而依据 vnode 新建一个真实的 DOM，删除旧的 DOM 节点。我们看看Vue是怎么diff的，继续看 patchVnode 代码 patchVnodehttps://github.com/wunci/vue/blob/dev/src/core/vdom/patch.js#L5011234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function patchVnode ( oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123; if (oldVnode === vnode) &#123; return &#125; .... let i const data = vnode.data if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const oldCh = oldVnode.children const ch = vnode.children if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode) if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) i(oldVnode, vnode) &#125; // 判断当前节点是否为文本节点 if (isUndef(vnode.text)) &#123; // 如果虚拟DOM的新旧children都存在，也就是子节点 if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 如果都存在，但是二者不相等，则需要对他们的children进行diff if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; else if (isDef(ch)) &#123; // 新的子节点如果存在但是旧的不存在，则需要把向旧的添加 if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(ch) &#125; if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '') addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; // 旧的子节点如果存在但是新的不存在，则需要把旧虚拟DOM原有的children删除 removeVnodes(oldCh, 0, oldCh.length - 1) &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, '') &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 文本不相同则替换新的文本 nodeOps.setTextContent(elm, vnode.text) &#125;&#125; patchVnode 相当于只能做到一层的判断，如果当前 diff 的虚拟DOM还存在 children 的话，需要进一步 diff，也就是使用 updateChildren updateChildrenhttps://github.com/wunci/vue/blob/dev/src/core/vdom/patch.js#L4041234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, vnodeToMove, refElm const canMove = !removeOnly if (process.env.NODE_ENV !== 'production') &#123; checkDuplicateKeys(newCh) &#125; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 如果oldStartVnode不存在，因为可能是undefined，后面处理可能会置为undefined if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; // 如果oldEndVnode不存在，跟上面情况类似，如果没有就收缩diff区间 oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // 新旧第一位的虚拟DOM相同，则可以局部渲染，diff区间都进一位，继续patch比较子节点(如果有children的话,如果没有就比较文本节点就可以了) patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // 新旧结尾的虚拟DOM相同，diff区间最后一位都向前进一位，继续patch比较子节点 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // 旧的开头和新的结尾判断是否一样，如果一样的话就的开头放到最后去，我们看它调用了insertBefore，按理不管怎样都不会在最后，因为它又使用了nextSibling， // nodeOps.nextSibling(oldEndVnode.elm)返回的就是null了，调用insertBefore就会把它放到parentElm的最后 patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // 同理上面 patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 这里会判断oldKeyToIdx是否定义，初次都是undefined，如果没有就会去通过key生成一个对象，比如你的key为 abc，当前下标为0，那么oldKeyToIdx = &#123;abc: 0,xxx: 1&#125; if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx) // 看看当前的key是否在里面，得到当前的idxInOld if (isUndef(idxInOld)) &#123; // New element // 如果没找到相应的key就证明当前是新元素。则直接创建 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; else &#123; // 如果找到 vnodeToMove = oldCh[idxInOld] // 并且是同类型的虚拟DOM，则先把当前置为undefined，证明当前已经处理了，然后把相应的元素插入到对应的位置 if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx) oldCh[idxInOld] = undefined canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm) &#125; else &#123; // 相同的key但是不同的元素就直接创建元素 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx) &#125; &#125; // 处理完当前新的虚拟DOM就进一位 newStartVnode = newCh[++newStartIdx] &#125; &#125; // 如果旧的开始 &gt; 旧的结尾下标，证明当前旧的虚拟DOM不够比较了，证明新的虚拟DOM明显比旧的元素多，就可以直接插入剩下的元素了 if (oldStartIdx &gt; oldEndIdx) &#123; refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; // 如果新的开始 &gt; 新的结尾下标，证明当前新的虚拟DOM不够比较了，证明新的虚拟DOM明显比旧的元素少，则需要把剩下的旧虚拟DOM移除掉 removeVnodes(oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 上面就是完整的diff算法了，可以直接看代码内的注释，你会发现进行最简单的判断，判断开始结尾是否相互一样，再通过key来查找元素，提高效率。 图解diff过程比如我们现在我们有data [A, B, C, D]，我们把他们改为 [B, C, A, D] 1&lt;div v-for="item in arr" :key="item"&gt;item&lt;/div&gt; 12345678910new Vue(&#123; data:&#123; arr: ['A', 'B', 'C', 'D'] &#125;, mounted()&#123; setTimeout(()=&gt;&#123; this.arr = ['B', 'C', 'A', 'D', 'F'] &#125;,1000) &#125;&#125;) 有key的情况解析👆：最开始的 startIdx 都是0，都会从最开始比对，第一位是 A 和 B，发现不一样，整个判断下来，发现前后都没有一样的元素，那么就会走第7个判断，通过key值来查找，他会去旧的虚拟DOM里找B元素，发现找了，先把他置为 undefined ，然后把他插入到A的前面，然后newStartIdx进一位，此轮diff完成 解析👆：现在newStartIdx来到了 C 这里，同样先看看有没有前后一样的，发现没有，又走到第7个判断里，通过 key 值来查找，找到 C 之后，把旧的C置为undefined，然后把C插入到A前面，然后newStartIdx进一位，此轮 diff 完成 解析👆：现在newStartIdx来到了 A 这里，同样先看看有没有前后一样的，发现旧的开始和新的开始位置一样，此时就不用改变位置了，直接oldStartIdx和newStartIdx都进一位，此轮diff完成 解析👆：我们发现oldStartIdx来到了B这里，但是B是已经是undefined的，此轮会走 if(isUndef(oldStartVnode)){}，直接oldStartIdx进一位。进一位之后发现又是undefined，继续+1，来到来D这里此时的oldStartIdx和oldEndIdx是一样的，此时的newStartIdx也是D，发现开始都相同，那么位置不用变，新旧的startIdx都进一位，你会发现此时的oldStartIdx &gt; oldEndIdx，大于的话就满足上面源码里if (oldStartIdx &gt; oldEndIdx) {} 解析👆：满足 if (oldStartIdx &gt; oldEndIdx) {} 我们需要把剩下的新的 虚拟DOM 插入到后面，也就是把F插入到最后 无key的情况👆看下来你会发现，为啥不带 key 貌似反而更快，因为咱们这里比较的都是文本节点，最简单的示例。为什么会直接赋值修改，你应该可以回过头看sameVnode的判断规则12345678910111213141516function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 不写 key，也满足第一个条件，然后 tag又都是 span，所以每次比较都会走 sameVnode(oldStartVnode, newStartVnode)，然后他们就会直接去修改 textContent。 所以在复杂的 DOM 中，我们还是要通过写 key 来提升渲染效率 总结本文讲解了Vue 虚拟DOM 的原理，带大家看了一下他的运行流程，以及关键的 diff 算法，也比较了有 key 和无 key 的 diff 过程，本文的示例比较简单，不能覆盖所有 diff 判断的条件，感兴趣可以自己去尝试。下一篇会带大家撸一个自己的 虚拟DOM，加深理解 本文地址 Vue源码之虚拟DOM]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码之双向数据绑定]]></title>
    <url>%2F2020%2F03%2F15%2Fvue-source-code-data-bind%2F</url>
    <content type="text"><![CDATA[前言近一年多都在做小程序开发，Vue 感觉都有写些生疏了，从今天开始阅读一下 Vue 的源码，了解其内部的工作机制，本文涉及的 Vue 版本为 2.6.11，我已经提前 fork 了一份到 github 上 双向数据绑定提到 Vue，自然会想到双向数据绑定，要说他的原理，你也能脱口而出，使用 Object.defineProperty 的 get、set来实现，但要把功能做更强大健壮，往往并不是这么简单。Vue的双向数据绑定由以下几个部分组成 Obserber监听器：负责数据的劫持调用Object.defineProperty来实现监听效果，get负责收集依赖，set负责派发更新 Dep订阅器：负责订阅者的收集，收集依赖 Watcher订阅者：负责更新视图 从入口开始https://github.com/wunci/vue/blob/dev/src/core/instance/init.js#L1512345678910111213141516171819202122export function initMixin (Vue: Class&lt;Component&gt;) &#123; Vue.prototype._init = function (options?: Object) &#123; ...... // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, 'created') ...... if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125; &#125;&#125; 从上面可以看出初始化 Vue 会调用多个函数来做不同的事情，本文主要讲解双向数据绑定，所以其他的在这里都不重要，这里我们着重关注 initState 内部方法 initStatehttps://github.com/wunci/vue/blob/dev/src/core/instance/state.js#L421234567891011121314151617export function initState (vm: Component) &#123; vm._watchers = [] const opts = vm.$options // 如果存在props，初始化props if (opts.props) initProps(vm, opts.props) // 挂载定义的方法 if (opts.methods) initMethods(vm, opts.methods) // 如果存在data，执行initData开始创建监听器 if (opts.data) &#123; initData(vm) &#125; else &#123; observe(vm._data = &#123;&#125;, true /* asRootData */) &#125; // 以下同理，都是初始化定义的一些数据 if (opts.computed) initComputed(vm, opts.computed) if (opts.watch) initWatch(vm, opts.watch)&#125; initDatahttps://github.com/wunci/vue/blob/dev/src/core/instance/state.js#L11212345function initData (vm: Component) &#123; .... // observe data observe(data, true /* asRootData */)&#125; observehttps://github.com/wunci/vue/blob/dev/src/core/observer/index.js#L1101234567891011121314151617181920212223export function observe (value: any, asRootData: ?boolean): Observer | void &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; let ob: Observer | void // 这里判断当前是否已经创建过Observer，如果有就直接返回 if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__ &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; // 这里是重点，创建一个Observer ob = new Observer(value) &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++ &#125; return ob&#125; Observer-监听器12345678910111213141516171819202122232425262728293031323334353637383940export class Observer &#123; value: any; dep: Dep; vmCount: number; // number of vms that have this object as root $data constructor (value: any) &#123; this.value = value this.dep = new Dep() this.vmCount = 0 // def其实就是给当前对象定义一个key为__ob__，值为this def(value, '__ob__', this) // 判断当前值是否为数组，如果是数组需要单独处理 // 因为我们知道vue主要原理是 Object.defineProperty，但是它监听不了数组的变化，所以3.0采用了proxy // 但是数组只能监听到部分方法的改动，感兴趣可以看 https://github.com/wunci/vue/blob/dev/src/core/observer/array.js if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods) &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys) &#125; this.observeArray(value) &#125; else &#123; this.walk(value) &#125; &#125; // 除了数组，都会调用该方法来劫持数据 walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; // 为数组创建Observer监听器 observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; defineReactive下面代码是双向数据绑定额核心 https://github.com/wunci/vue/blob/dev/src/core/observer/index.js#L13512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 创建dep，主要做依赖收集 const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) // 判断当前对象是否可定义，不能的话后面执行也没有意义了，所以直接return if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 是否有自定义get set const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set // 取当前的值 if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; // shallow为undfined，因为上一步没有传，只有定义$attrs和$listeners使用true // 继续调用observe(val)劫持 let childOb = !shallow &amp;&amp; observe(val) // 重头戏，调用Object.defineProperty Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 此时的Dep.target是一个Watcher类，Dep.target全局只有一个 if (Dep.target) &#123; // 订阅 dep.depend() // 如果数据是对象，继续 if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; const value = getter ? getter.call(obj) : val if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; ...... if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; // 把值更新为最新的 val = newVal &#125; // 把新值变成响应式的对象 childOb = !shallow &amp;&amp; observe(newVal) // 数据发生变化之后通知 dep.notify() &#125; &#125;)&#125; Dep-订阅器Dep 在 Vue 里面也是关键的一环，它负责依赖收集，从上面 defineReactive 内部方法有看到实例化了一个 dep，然后有使用到Dep.target、dep.depend()、dep.notify()，那么我们来看看 Dep 的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051let uid = 0/** * A dep is an observable that can have multiple * directives subscribing to it. */export default class Dep &#123; static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // 收集依赖 depend () &#123; if (Dep.target) &#123; // Dep.target是一个Watcher类，所以Dep.target.addDep调用的是Watcher类里面的方法 Dep.target.addDep(this) &#125; &#125; notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125;// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.Dep.target = nullconst targetStack = []// 该方法会用在Watcher内部export function pushTarget (_target: Watcher) &#123; if (Dep.target) targetStack.push(Dep.target) Dep.target = _target&#125;// 和上面方法一样，调用完pushTarget之后接着会调用popTarget，删除当前目标watcherexport function popTarget () &#123; Dep.target = targetStack.pop()&#125; 为什么 Dep.target 会有值呢？因为实例化一个 Watcher 会调用 pushTarget，但是什么时候会实例化 Watcher 呢？1. 初始化 initComputed 2. 绑定 $watch 3. mountComponent。实际上是来自 mountComponent 内部的实例化 Watcher，我们看看代码 https://github.com/wunci/vue/blob/dev/src/core/instance/lifecycle.js#L141 mountComponent12345678910111213141516171819202122232425262728293031323334353637383940414243export function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; vm.$el = el if (!vm.$options.render) &#123; ..... &#125; callHook(vm, 'beforeMount') let updateComponent /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; updateComponent = () =&gt; &#123; ...... &#125; &#125; else &#123; updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating) &#125; &#125; // we set this to vm._watcher inside the watcher's constructor // since the watcher's initial patch may call $forceUpdate (e.g. inside child // component's mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate') &#125; &#125; &#125;, true /* isRenderWatcher */) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true callHook(vm, 'mounted') &#125; return vm&#125; 上面代码很重要，主要是视图的初始化过程，我们还可以看到两个生命周期，beforeMount和mounted，实例化Watcher，传递了几个主要参数，分别是vm、updateComponent、和一个 before 方法，vm 就是当前 Vue 的this了，重点在 updateComponent 方法，内部是 vm._update(vm._render(), hydrating) ，既然是初始化渲染视图，那么它也没有调用呀，我们先说 vm._render()，它的作用是生成当前 vnode，也就是虚拟 dom，通过 vm.__update 来更新视图，这里其实就牵扯到了新旧虚拟 dom 的比较，也就是 diff 算法，我们知道现在是初始化，也就是说只有一个 vnode，直接渲染就可以了，关键是在这里它没有执行，所以接下来我们需要看看 Watcher 做了什么 Wachter-订阅者https://github.com/wunci/vue/blob/dev/src/core/observer/watcher.js#L261234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980export default class Watcher &#123; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; this.vm = vm if (isRenderWatcher) &#123; vm._watcher = this &#125; vm._watchers.push(this) // options if (options) &#123; this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync this.before = options.before &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false &#125; this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== 'production' ? expOrFn.toString() : '' // parse expression for getter if (typeof expOrFn === 'function') &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) if (!this.getter) &#123; this.getter = noop ... &#125; &#125; this.value = this.lazy ? undefined : this.get() &#125; get () &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; ..... &#125; finally &#123; // "touch" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125; &#125; .... 我们上一步实例化了 Wathcer，传入了一些参数，Watcher 内部构造函数最后执行了 this.get()，也就是内部 get 方法，重点来了12345678910111213141516171819get () &#123; pushTarget(this) let value const vm = this.vm try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; ..... &#125; finally &#123; // "touch" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value) &#125; popTarget() this.cleanupDeps() &#125; return value &#125; 首先它会调用之前的方法 pushTarget 来赋值 Dep.target，所以我们会知道 Dep.target 一定是一个Watcher，紧接着调用了this.getter，getter是什么？getter实际就是传进来的第二个参数expOrFn，是一个方法。之前我们说的 mountComponent 方法内部传入的 updateComponent 方法，会在这里被调用，达到初始化视图的作用。继续往下看，我们可以看到 addDep 方法，是不是很眼熟，之前我们说了 Vue 劫持数据，在 get 内会收集依赖，调用 dep.depend() 方法，然后 depend 方法执行了 Dep.target.addDep(this)，接着会调用这里我们说的 addDep 方法，传入的 this 就是 Dep12345678910addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 首先判断是否已经存在 dep，没有就往调用 dep 的方法 addSub 追加当前的 Watcher，调用 addSub 会存在 dep 内的 subs，subs是一个数组，整个流程是不是很绕，我们可以画个图来看看 派发更新我们收集了依赖有什么用呢？我们修改值之后需要更新视图和数据，这个动作我们是可以预知的，因为会触发之前的setter，setter内部调用了 dep.notify()，这个时候就可以通知所有订阅者更新视图setter1234567891011121314151617181920set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (customSetter) &#123; customSetter(); &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); dep.notify();&#125; dep.notify()会调用 dep 的 notify 方法，我们知道 subs 内部都是 Watcher 类的数组，需要更新全部就得其遍历他们，执行 Watcher 内部的 update 方法1234567891011121314151617181920212223export default class Dep &#123; constructor () &#123; this.id = uid++ this.subs = [] &#125; .... notify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; // subs aren't sorted in scheduler if not running async // we need to sort them now to make sure they fire in correct // order subs.sort((a, b) =&gt; a.id - b.id) &#125; for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; updatehttps://github.com/wunci/vue/blob/dev/src/core/observer/watcher.js#L16412345678910update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 实际上大部分情况都会直接执行 queueWatcher 方法 https://github.com/wunci/vue/blob/dev/src/core/observer/scheduler.js#L164 queueWatcher1234567891011121314151617181920212223242526272829export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; // 如果已经刷新，则根据其ID拼接订阅者 // 如果已经超过其ID，它将立即运行 let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; waiting = true // 开发环境并且不是异步的就直接执行 if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; // 这里其实就是执行了个异步操作，可以了解一些nextTick的实现 // https://github.com/wunci/vue/blob/dev/src/core/util/env.js#L51 nextTick(flushSchedulerQueue) &#125; &#125;&#125; https://github.com/wunci/vue/blob/dev/src/core/observer/scheduler.js#L71 flushSchedulerQueue1234567891011121314151617181920212223242526272829303132333435function flushSchedulerQueue () &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id //在刷新之前对队列进行排序。 //这样可以确保： //1.组件从父级更新为子级。 （因为父母总是在子级之前创建） //2.组件的用户监视程序先于其呈现监视程序运行（因为用户订阅者先于渲染订阅者创建） //3.如果在父组件的订阅者运行期间破坏了某个组件，可以跳过其订阅者 queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] // 调用之前执行一下before，目的是可以触发beforeUpdate生命周期 if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 // 判断是否死循环了 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; .... break &#125; &#125; &#125; ....&#125; 上面代码主要是对 queue 内的数据根据 watcher 的 id 来排序，确保数据是从父级更新到子级，因为是有先后顺序的，先有父后有子。接着就是批量去更新他们，可以看到先执行了before方法，然后调用了 watcher 的 run 方法，我们来看看 run 方法的代码run1234567891011121314151617181920212223242526run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125; 我们主要关注const value = this.get()这段代码，其实this.get我们之前就说过了，初始化的时候它就会调用，实际上执行的是以下代码123updateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; 自此整个流程已经讲完，以上流程可以通过下面一张图来表达 总结至此双向数据绑定的全部流程已经全部讲完，你会发现主要是通过Observer、Dep、Watcher来串起来整个流程，其中当然还有很多可以单独提取出来讲的，本文还会继续完善补充 本文地址 Vue源码之双向数据绑定]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个守护进程]]></title>
    <url>%2F2020%2F03%2F08%2Fwrite-daemon%2F</url>
    <content type="text"><![CDATA[为什么我们编写node程序的时候，立马会去执行它，如下所示 12345// app.jsconst http = require("http");http.createServer((req, res) =&gt; &#123; res.end("hello world");&#125;).listen(3000); 执行下面命令运行1node app.js 我们接着访问3000端口，貌似没毛病。但是当你退出命令行窗口或者 ctrl+c 终止了程序，再去访问这个程序发现它炸了！你很不解，开始抱怨上天为什么这样对你，然后。。。额，算了，玩笑到此为止，那么怎么才能让它再后台运行呢？ 背景市面上也有很多进程守护工具，比如 pm2 forever 当然如果我们使用docker，就不需要这些了 编写编写之前想运行流程 创建一个父进程 父进程下面构建出一个子进程 父进程退出 第一个流程没问题，第二个，我们怎么创建一个子进程呢？这里我们需要借助child_process，名字就很明显了，子进程。我们可以借助方法 spawn 来实现，用得比较多的还有exec方法（可以执行shell命令）123456789101112const spawn = require("child_process").spawn;const child = spawn("node", ["app.js"], &#123; detached: true, stdio: "ignore"&#125;);child.on("close", function(code) &#123; console.log("close", code);&#125;);child.on("error", function(code) &#123; console.log("error", code);&#125;);console.log(process.pid, child.pid); 从上图我们看到，开启了两个进程，38715是父进程，38716是子进程，至此我们实现了步骤二 接着我们实现步骤三，往下增加下面一段代码123child.unref();//orprocess.exit() 现在我们可以打开浏览器查看3000端口是否依然可以访问正常 扩展-使用cluster上面我们只开启了一个子进程，没有充分利用多核系统，尽可能的压榨机器。我们所熟知的pm2就是基于这个来实现的 下面是官网的一个示例，我们可以把之前的app.js替换为下面的代码12345678910111213141516171819202122232425const cluster = require('cluster');const http = require('http');const numCPUs = require('os').cpus().length;if (cluster.isMaster) &#123; console.log(`主进程 $&#123;process.pid&#125; 正在运行`); // 衍生工作进程。 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork(); &#125; cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`); &#125;);&#125; else &#123; // 工作进程可以共享任何 TCP 连接。 // 在本例子中，共享的是 HTTP 服务器。 http.createServer((req, res) =&gt; &#123; res.writeHead(200); res.end('你好世界\n'); &#125;).listen(8000); console.log(`工作进程 $&#123;process.pid&#125; 已启动`);&#125; 可以看到我们又开启了多个子进程，来达到负载均衡，还有进程间通信相关的知识就不往下说了。 总结至此我们实现了一个最最简单的守护进程，然而好像并没有什么用？感兴趣的可以去看 pm2 的源码，不过就是有点多。可以去看看 egg-cluster 的实现，关于这方面的知识还有很多需要学习的地方，行了，又有两车砖来了，今天先到这，希望下一篇可以深入分享 本文地址 编写一个守护进程]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa源码系列之全流程解析]]></title>
    <url>%2F2019%2F12%2F23%2FKoa%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%A8%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面之前我们已经讲解了koa源码中的一些依赖包，Koa源码系列之依赖包解析 Koa源码系列之koa-compose，现在我们来看看koa源码的全流程 解析我们首先来看看最简单的用法，一下是官网的示例12345678const Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 首先我们引入koa包，然后实例化一个对象，也就是const = new Koa()。然后调用use方法，这个方法之前在Koa源码系列之koa-compose讲过，用处就是挂载中间件。当前内部执行的方法就是向前端返回一个hello world的内容，最后我们将应用挂载在3000端口下，这个listen很重要，因为一切我们定义的的方法都会从这里执行。我们看看 Koa 的构造函数的主入口是从哪暴露的，先来🤔思考一个问题，我们怎么快速找到一个包的主入口呢？如果你发布过npm包就知道，我们可以在package.json内找到main，koa的内容是 &quot;main&quot;: &quot;lib/application.js&quot;，现在我们可以直接去查看lib下的application文件，是不是很方便？ 接下来部分解析可能在代码注释内https://github.com/koajs/koa/blob/master/lib/application.js#L30123456789101112131415161718192021module.exports = class Application extends Emitter &#123; constructor(options) &#123; super(); options = options || &#123;&#125;; this.proxy = options.proxy || false; this.subdomainOffset = options.subdomainOffset || 2; this.proxyIpHeader = options.proxyIpHeader || 'X-Forwarded-For'; this.maxIpsCount = options.maxIpsCount || 0; this.env = options.env || process.env.NODE_ENV || 'development'; if (options.keys) this.keys = options.keys; // 存放中间件 this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response); if (util.inspect.custom) &#123; this[util.inspect.custom] = this.inspect; &#125; &#125; ...&#125; 以上代码就是暴露出来的构造函数，所以我们可以使用new Koa()的形式调用，它继承了（extends Emitter这段代码）node提供的原生 events（事件触发器）方法，那么它在哪用到了呢？我们知道koa可以使用 app.on(&#39;error&#39;) 来监听错误，可以看下面代码123app.on('error', err =&gt; &#123; log.error('server error', err)&#125;); 我们添加了一个 “error” 事件侦听器，那么它在哪会触发，理想的代码肯定是 xxx.emit(&#39;error&#39;, ...)，搜索一下就知道，代码在 lib/context下的onerror，当程序出错走会走这个onerror方法。 继续看构造函数内代码，我们可以传递option，当前this下面挂载了讲过属性，分别是 proxy（代理） subdomainOffset（作用是子域偏移数） proxyIpHeader maxIpsCount env，这几个属性都可以从外部传入，当然不传的话会有默认值，比如env标记开发环境的变量，默认是 &#39;development&#39;。 往下看到有一个 this.middleware = []，这里是存放中间件的，app.use()内的方法都会push到这个数组内，那么它在哪会执行这些数组内部的方法呢？它会在当前实例的callback函数内调用，这个后面再讲。 然后继续看后面紧跟着三个创建对象的赋值的操作，分别是 context/request/response，他们其实都是来自另外三个文件暴露出来的对象。他们的作用简单来说就是对对象数据层做了处理，添加了很多方法，比如我们使用 ctx.redirect ctx.body ctx.query等等，都来自这三个对象内方法。后面会细说，先讲最外层的方法。 那么执行完构造函数，程序还是跑不起来不是？我们知道原生的创建一个后台应用需要使用到http.createServer，到目前为止我们还没有说到，我们先来看看原生怎么创建的12345var http = require('http');http.createServer(function (request, response) &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.end('Hello World\n');&#125;).listen(8888); 我们之前讲过app.listen方法是创建应用的关键，我们来看看源码https://github.com/koajs/koa/blob/master/lib/application.js#L7712345listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args);&#125; 是不是跟之前我们写的很像？看上面代码可以看出执行listen构建了一个服务，调用了callback方法，继续看callbackhttps://github.com/koajs/koa/blob/master/lib/application.js#L141123456789101112callback() &#123; const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest;&#125; 回调内部首先执行了中间件，调用了compose，这个上上篇文章讲过，继续看，最后返回了一个处理请求的函数handleRequest，接收两个参数req，res，其实就是之前我们原生创建应用返回的数据，内部继续调用了this.createContext，该方法主要是对数据进行处理，源码如下：1234567891011121314createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context;&#125; 从上面可以看出，它的功能主要是对数据进行进一步处理，把它挂载多个key上，这也就是我们可以使用ctx.req和ctx.response的原因。等会会讲到this.context/this.request/this.response内部的实现。callback回调内部使用this.handleRequest方法来处理结果，我们看一下源码https://github.com/koajs/koa/blob/master/lib/application.js#L16012345678handleRequest(ctx, fnMiddleware) &#123; const res = ctx.res; res.statusCode = 404; const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fnMiddleware(ctx).then(handleResponse).catch(onerror);&#125; 上面的代码很好理解，意思就是中间件执行完后，再异步里处理返回请求的信息，也就是respond方法，如果内部报错自然会走catch方法，然后处理的函数是lib/context.js文件下暴露的onerror方法，这个方法上面有讲过。我们具体看一下koa是怎么处理请求返回数据的。 🤔分析之前我们先思考一下开发的时候是怎么返回数据给前端的？我们使用ctx.body = &#39;xx&#39;，当然这个值不一定是字符串，可以是对象、buffer等。然后思考一下原生的使用最后一般返回数据是怎么样的呢？肯定不是ctx.body，这个只是个语法糖而已，熟悉的人应该立马就知道，原生返回数据我们都是使用res.end(data)的形式返回，这里就可以猜测，koa肯定是先取到了我们ctx.body的值，最后使用res.end(data)来返回数据的。 respond方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function respond(ctx) &#123; // allow bypassing koa if (false === ctx.respond) return; if (!ctx.writable) return; const res = ctx.res; let body = ctx.body; const code = ctx.status; // ignore body if (statuses.empty[code]) &#123; // strip headers ctx.body = null; return res.end(); &#125; if ('HEAD' === ctx.method) &#123; if (!res.headersSent &amp;&amp; !ctx.response.has('Content-Length')) &#123; const &#123; length &#125; = ctx.response; if (Number.isInteger(length)) ctx.length = length; &#125; return res.end(); &#125; // status body if (null == body) &#123; if (ctx.req.httpVersionMajor &gt;= 2) &#123; body = String(code); &#125; else &#123; body = ctx.message || String(code); &#125; if (!res.headersSent) &#123; ctx.type = 'text'; ctx.length = Buffer.byteLength(body); &#125; return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); if (!res.headersSent) &#123; ctx.length = Buffer.byteLength(body); &#125; res.end(body);&#125; 好了，根据之前的理解，再看一下上面的代码是不是清楚很多？不过其中koa还是做了一些数据的处理，比如如果我们ctx.body = {}，koa会自动把对象转字符串，然后就算返回数据的length，最后再调用res.end(body)。 context.jshttps://github.com/koajs/koa/blob/master/lib/context.js 之前说过会讲到三个文件暴露出来的方法，这是其中一个。他们其实都是对数据进行了一系列的处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980'use strict';/** * Module dependencies. */const util = require('util');const createError = require('http-errors');const httpAssert = require('http-assert');const delegate = require('delegates');const statuses = require('statuses');const Cookies = require('cookies');const COOKIES = Symbol('context#cookies');const proto = module.exports = &#123; inspect() &#123; if (this === proto) return this; return this.toJSON(); &#125;, toJSON() &#123; ... &#125;, assert: httpAssert, throw(...args) &#123; throw createError(...args); &#125;, onerror(err) &#123; ... &#125;, get cookies() &#123; if (!this[COOKIES]) &#123; this[COOKIES] = new Cookies(this.req, this.res, &#123; keys: this.app.keys, secure: this.request.secure &#125;); &#125; return this[COOKIES]; &#125;, set cookies(_cookies) &#123; this[COOKIES] = _cookies; &#125;&#125;;if (util.inspect.custom) &#123; module.exports[util.inspect.custom] = module.exports.inspect;&#125;delegate(proto, 'response') ... .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable');delegate(proto, 'request') ... .getter('host') .getter('hostname') .getter('URL') .getter('header') .getter('headers') .getter('secure') .getter('stale') .getter('fresh') .getter('ips') .getter('ip'); 以上就是context的全部内容，我做了精简，把注释和一些相似的代码删除了，但是方法上面全部都在，context你可以直接理解为我们经常使用的ctx，ctx下面是不是有很多方法？其实基本上都是末尾delegate方法处理之后得到的，我们可以看到它分别处理了response、request，其实就算请求体和响应体，上篇文章我们介绍过它的机制，我们使用的ctx.body、ctx.header、ctx.query….基本上方法都可以在这里看到。除了这些，上面还有获取cookie和设置cookie的方法，还有我们之前讲到的 onerror 方法， request.js现在我们自然可以知道，body/header/query这些方法都放在另外两个文件下面，requset下面会有host/hostname/URL/header…..方法，我们这里只看部分方法，因为方法有点多，篇幅很长123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384const URL = require('url').URL;const net = require('net');const accepts = require('accepts');const contentType = require('content-type');const stringify = require('url').format;const parse = require('parseurl');const qs = require('querystring');const typeis = require('type-is');const fresh = require('fresh');const only = require('only');const util = require('util');const IP = Symbol('context#ip');/** * Prototype. */module.exports = &#123; /** * Return request header. * * @return &#123;Object&#125; * @api public */ get header() &#123; return this.req.headers; &#125;, /** * Set request header. * * @api public */ set header(val) &#123; this.req.headers = val; &#125;, /** * Return request header, alias as request.header * * @return &#123;Object&#125; * @api public */ get headers() &#123; return this.req.headers; &#125;, /** * Set request header, alias as request.header * * @api public */ set headers(val) &#123; this.req.headers = val; &#125;, /** * Get request URL. * * @return &#123;String&#125; * @api public */ get url() &#123; return this.req.url; &#125;, /** * Set request URL. * * @api public */ set url(val) &#123; this.req.url = val; &#125;, ...&#125; 上面就是部分request内的方法，是不是很简单，就是一些获取和值的设置。123456get header() &#123; return this.req.headers;&#125;,set header(val) &#123; this.req.headers = val;&#125;, 比如上面获取我设置header会有两个方法，ctx.header，会调用第一个get方法，赋值则会走第二个方法，那么this.req是什么呢，我们肯定知道是http.createServer回调返回的req信息，那么this具体是什么呢？之前我们就讲过在application.js内的createContext方法，request赋值给了context.requset，然后context.js内部通过delegate代理了数据，context下也定义了req对象，这样我们就可以直接使用this.req直接获取数据1234567891011121314createContext(req, res) &#123; const context = Object.create(this.context); const request = (context.request = Object.create(this.request)); const response = (context.response = Object.create(this.response)); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.state = &#123;&#125;; return context;&#125; response.js这里跟上面的原理一样，我们简单看一下部分代码吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146module.exports = &#123; get status() &#123; return this.res.statusCode; &#125;, /** * Set response status code. * * @param &#123;Number&#125; code * @api public */ set status(code) &#123; if (this.headerSent) return; assert(Number.isInteger(code), 'status code must be a number'); assert(code &gt;= 100 &amp;&amp; code &lt;= 999, `invalid status code: $&#123;code&#125;`); this._explicitStatus = true; this.res.statusCode = code; if (this.req.httpVersionMajor &lt; 2) this.res.statusMessage = statuses[code]; if (this.body &amp;&amp; statuses.empty[code]) this.body = null; &#125;, /** * Get response status message * * @return &#123;String&#125; * @api public */ get message() &#123; return this.res.statusMessage || statuses[this.status]; &#125;, /** * Set response status message * * @param &#123;String&#125; msg * @api public */ set message(msg) &#123; this.res.statusMessage = msg; &#125;, /** * Get response body. * * @return &#123;Mixed&#125; * @api public */ get body() &#123; return this._body; &#125;, /** * Set response body. * * @param &#123;String|Buffer|Object|Stream&#125; val * @api public */ set body(val) &#123; const original = this._body; this._body = val; // no content if (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove('Content-Type'); this.remove('Content-Length'); this.remove('Transfer-Encoding'); return; &#125; // set the status if (!this._explicitStatus) this.status = 200; // set the content-type only if not yet set const setType = !this.has('Content-Type'); // string if ('string' == typeof val) &#123; if (setType) this.type = /^\s*&lt;/.test(val) ? 'html' : 'text'; this.length = Buffer.byteLength(val); return; &#125; // buffer if (Buffer.isBuffer(val)) &#123; if (setType) this.type = 'bin'; this.length = val.length; return; &#125; // stream if ('function' == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove('Content-Length'); if (setType) this.type = 'bin'; return; &#125; // json this.remove('Content-Length'); this.type = 'json'; &#125;, /** * Set Content-Length field to `n`. * * @param &#123;Number&#125; n * @api public */ set length(n) &#123; this.set('Content-Length', n); &#125;, /** * Return parsed response Content-Length when present. * * @return &#123;Number&#125; * @api public */ get length() &#123; if (this.has('Content-Length')) &#123; return parseInt(this.get('Content-Length'), 10) || 0; &#125; const &#123; body &#125; = this; if (!body || body instanceof Stream) return undefined; if ('string' === typeof body) return Buffer.byteLength(body); if (Buffer.isBuffer(body)) return body.length; return Buffer.byteLength(JSON.stringify(body)); &#125;, ...&#125; 上面是部分代码，看起来很容易理解，获取状态码使用ctx.status，也可以设置。这里我们值得看看body方法，看看它是怎么处理的，我们经常使用的ctx.body就是来自这里body方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758set body(val) &#123; const original = this._body; this._body = val; // no content // 如果没有内容返回状态码204 if (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove('Content-Type'); this.remove('Content-Length'); this.remove('Transfer-Encoding'); return; &#125; // set the status // 如果我们没有设置状态码，默认是200，this._explicitStatus在set status方法内会有赋值，意思是如果我们显示的设置了状态码，那么它的值为true if (!this._explicitStatus) this.status = 200; // set the content-type only if not yet set // 这里意思是，如果我们没有设置content-type的时候，判断是否需要设置数据类型 const setType = !this.has('Content-Type'); // string // 如果是字符串类型 if ('string' == typeof val) &#123; // 如果需要设置content-type，那么会有两种类型，html、text if (setType) this.type = /^\s*&lt;/.test(val) ? 'html' : 'text'; // 顺便设置他们的length this.length = Buffer.byteLength(val); return; &#125; // buffer // 如果是buffer，并且需要设置content-type，那么指定类型为bin，同样需要设置length if (Buffer.isBuffer(val)) &#123; if (setType) this.type = 'bin'; this.length = val.length; return; &#125; // stream // 如果是流文件，类型仍然是bin if ('function' == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove('Content-Length'); if (setType) this.type = 'bin'; return; &#125; // json // 最后剩下的只有json类型了 this.remove('Content-Length'); this.type = 'json';&#125;, 总结大体对koa执行的流程分析了一遍，总体来说还是很好理解的，就是用文字表达出来可能不太理想，现在其实我们已经可以写一个自己的koa了。本文还会继续完善，如有错误，还望指正。 原文地址：http://wunci.github.io/2019/12/23/Koa源码系列之全流程解析/]]></content>
      <categories>
        <category>javascript</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa源码系列之依赖包解析]]></title>
    <url>%2F2019%2F12%2F16%2FKoa%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BE%9D%E8%B5%96%E5%8C%85%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面上一篇我们讲了 Koa源码系列之koa-compose，其实也可以归为到这篇文章。今天开始我们看看Koa源码中使用了哪些包，他们起到了什么作用。ps: 这里不准备讲所有的包 is-generator-functionhttps://github.com/koajs/koa/blob/master/lib/application.js#L122123456789101112use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125; 可以看看上面一段代码，koa在注入中间件的之前先判断传入是否是函数，然后判断当前传入的函数是否是 generator，如果是 generator 那么使用convert（koa-convert包，下面会讲到）进行转换，其实转换出来返回的是一个 promise，那么怎么判断是否是 generator 函数的呢？使用了isGeneratorFunction方法，也就是 is-generator-function包，下面是源码https://github.com/inspect-js/is-generator-function/blob/master/index.js1234567891011121314151617181920212223242526272829303132var toStr = Object.prototype.toString;var fnToStr = Function.prototype.toString;var isFnRegex = /^\s*(?:function)?\*/; var hasToStringTag = typeof Symbol === 'function' &amp;&amp; typeof Symbol.toStringTag === 'symbol';var getProto = Object.getPrototypeOf;var getGeneratorFunc = function () &#123; // eslint-disable-line consistent-return if (!hasToStringTag) &#123; return false; &#125; try &#123; return Function('return function*() &#123;&#125;')(); &#125; catch (e) &#123; &#125;&#125;;var generatorFunc = getGeneratorFunc();var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : &#123;&#125;;module.exports = function isGeneratorFunction(fn) &#123; // 首先判断是否是函数，如果不是直接返回false if (typeof fn !== 'function') &#123; return false; &#125; // 先将函数转为字符串，然后正则匹配判断 if (isFnRegex.test(fnToStr.call(fn))) &#123; return true; &#125; if (!hasToStringTag) &#123; var str = toStr.call(fn); return str === '[object GeneratorFunction]'; &#125; return getProto(fn) === GeneratorFunction;&#125;; 函数转字符串正则匹配1var isFnRegex = /^\s*(?:function)?\*/; 上面代码正则匹配 function* (){}，这里其实匹配有问题，因为可以写成 function * (){}，没有规定*一定到紧跟function，正则可以改成 /^\s*(?:function)?(\s+)?\*/ 判断Symbol.toStringTag1var hasToStringTag = typeof Symbol === 'function' &amp;&amp; typeof Symbol.toStringTag === 'symbol'; 上面这段代码很多人其实很疑惑，其实这里就想得出有没有Symbol以及有没有toStringTag方法，这个很重要，如果存在toStringTag，那么我们用 Object.prototype.toString来判断数据类型变得不可靠了。我们可以看下面这段代码1234567class ValidatorClass &#123; get [Symbol.toStringTag]() &#123; return 'Validator'; &#125;&#125;console.log(Object.prototype.toString.call(new ValidatorClass()));// expected output: "[object Validator]" 有了toStringTag方法，我们可以伪造数据类型，这肯定会有风险，所以之前首先判断是否存在，如果存在它会使用 Object.getPrototypeOf来判断他们的原型是不是来自同一个，也就是下面的代码1234567var generatorFunc = getGeneratorFunc();var getProto = Object.getPrototypeOf;var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : &#123;&#125;;...return getProto(fn) === GeneratorFunction; 直接使用Object.prototype.toString如果不存在Symbol.toStringTag，那么自然我们可以使用 Object.prototype.toString 来判断数据类型1234if (!hasToStringTag) &#123; var str = toStr.call(fn); return str === '[object GeneratorFunction]';&#125; delegates在koa内使用https://github.com/koajs/koa/blob/master/lib/context.js#L191123456789101112131415161718192021/** * Response delegation. */delegate(proto, 'response') .method('attachment') .method('redirect') .method('remove') .method('vary') .method('has') .method('set') .method('append') .method('flushHeaders') .access('status') .access('message') .access('body') .access('length') .access('type') .access('lastModified') .access('etag') .getter('headerSent') .getter('writable'); 乍一看看不出它有啥用处，其实很简单，它相当于做了代理，本来我们访问body需要ctx.response.body，现在你只需要ctx.body就可以了。是不是很简单？那么我们看一下这个包的源码具体怎么实现的123456789101112131415function Delegator(proto, target) &#123; ...&#125;Delegator.prototype.getter = function(name)&#123; ...&#125;;Delegator.prototype.access = function(name)&#123; ...&#125;;Delegator.prototype.setter = function(name)&#123; ...&#125;;Delegator.prototype.method = function(name)&#123; ...&#125;; 上面的👆代码就是 delegates 包的大致总体结构，还有其他几个方法这里不做介绍。我们可以先来看一下方法 Delegator 构造函数12345678910function Delegator(proto, target) &#123; if (!(this instanceof Delegator)) return new Delegator(proto, target); this.proto = proto; this.target = target; // 以下可以忽略 this.methods = []; this.getters = []; this.setters = []; this.fluents = [];&#125; 从上面我们可以看到，接收两个参数，分别是对应的对象和目标key值，koa使用的是 delegate(proto, &#39;response&#39;)，proto就是ctx，response就是目标key值。 继续看getter1234567891011Delegator.prototype.getter = function(name)&#123; var proto = this.proto; var target = this.target; this.getters.push(name); proto.__defineGetter__(name, function()&#123; return this[target][name]; &#125;); return this;&#125;; 通过以上代码可以得知，它使用的是__defineGetter__来代理获取值，访问ctx.body的时候，其实返回的值是 this[target][name]，target我们已经知道，是response，然后在这里body就是name了。但是我查看 defineGetter 这个api，发现 该特性是非标准的，请尽量不要在生产环境中使用它！，我们思考以下，其实我们可以使用Object.defineProperty，把它进行改造12345Object.defineProperty(proto, name, &#123; get: function() &#123; return this[target][name]; &#125;&#125;); 其实我们看一下该项目的PR会发现，已经有人提了PR，但是一直没有meger。剩下的可以同理，setter使用的是__defineSetter__方法，我们就可以借助Object.defineProperty的set进行改造。access方法则是两者方法的集合，如果满足可以获取值和设置值条件，都可以使用access，比较方便，它的源码也很好理解，同时调用 get和set123Delegator.prototype.access = function(name)&#123; return this.getter(name).setter(name);&#125;; koa-convert我们在上个模块看到了Koa源码有判断中间件传入的是否是 generator ，如果是true，那么它就调用了 convert(fn)，也就是这个模块需要解析的包 koa-convert，那么他到底有什么用呢？看下面他的源码 12345678910111213141516171819202122232425262728293031const co = require('co')const compose = require('koa-compose')module.exports = convertfunction convert (mw) &#123; if (typeof mw !== 'function') &#123; throw new TypeError('middleware must be a function') &#125; if (mw.constructor.name !== 'GeneratorFunction') &#123; // assume it's Promise-based middleware return mw &#125; const converted = function (ctx, next) &#123; return co.call(ctx, mw.call(ctx, createGenerator(next))) &#125; converted._name = mw._name || mw.name return converted&#125;function * createGenerator (next) &#123; return yield next()&#125;convert.compose = function (arr) &#123; if (!Array.isArray(arr)) &#123; arr = Array.from(arguments) &#125; return compose(arr.map(convert))&#125;convert.back = function (mw) &#123; ...&#125; 我们可以直接跳到第13行代码，直观的看到他使用了 co 方法，通过 co包（这里不展开讲这个包）处理返回的结果拿到最终需要转换的函数，使用 call 主要是想把 this 指向 ctx 对象。通过co处理得到的是一个 Promise对象，当然 convert 下还有两个方法，这里介绍一下，一个是 compose，看过上篇文章的应该知道，它依赖了 koa-compose，主要功能是将一个数组里的中间件全转成 Promise 对象。另一个方法是back，字面意思就能知道，就是回退，可以把函数转成 generator only看了koa源码你会发现在好几个地方用到了这个依赖包，这个包主要是输出你想要的对象数据，例子如下12345678910111213var obj = &#123; name: &apos;tobi&apos;, last: &apos;holowaychuk&apos;, email: &apos;tobi@learnboost.com&apos;, _id: &apos;12345&apos;&#125;;var user = only(obj, &apos;name last email&apos;);输出：&#123; name: &apos;tobi&apos;, last: &apos;holowaychuk&apos;, email: &apos;tobi@learnboost.com&apos;&#125; koa源码使用的例子 https://github.com/koajs/koa/blob/master/lib/application.js#L921234567toJSON() &#123; return only(this, [ 'subdomainOffset', 'proxy', 'env' ]);&#125; 依赖包源码 https://github.com/tj/node-only/blob/master/index.js123456789module.exports = function(obj, keys)&#123; obj = obj || &#123;&#125;; if ('string' == typeof keys) keys = keys.split(/ +/); return keys.reduce(function(ret, key)&#123; if (null == obj[key]) return ret; ret[key] = obj[key]; return ret; &#125;, &#123;&#125;);&#125;; 代码很简单，看源码知道，我们可以传字符串或者直接数组的形式传递需要的key值，默认定义一个空对象，调用reduce把结果循环传递下去，最终返回，如果没找指定的value，直接返回ret。额，感觉没有讲的必要，那么就。。。 总结本来一股脑想讲5 6个依赖包，但是看了一下，简单的讲起来感觉有点没意思，大部分依赖包内部又依赖其他包，想讲明白其实不容易，篇幅太长，所以先讲到这里吧，下一篇讲讲总体的koa构造流程，有一个更清楚的认识，毕竟看源码也主要是为了这一点。 原文地址：http://wunci.github.io/2019/12/16/Koa源码系列之依赖包解析/]]></content>
      <categories>
        <category>javascript</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa源码系列之koa-compose]]></title>
    <url>%2F2019%2F12%2F11%2FKoa%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8Bkoa-compose%2F</url>
    <content type="text"><![CDATA[写在前面 从今天开始阅读学习一下Koa源码，Koa对前端来说肯定不陌生，使用node做后台大部分会选择Koa来做，Koa源码的代码量其实很少，接下来让我们一层层剥离，分析其中的源码 Koa用法12345678const Koa = require("koa");const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = &#123; a: 1 &#125;;&#125;);app.listen(3000); 浏览器打开 http://localhost:3000 可以看到返回了一个对象 {a:1} 洋葱模型Koa最经典的就是基于洋葱模型的HTTP中间件处理流程，可以看下图 看下面代码是否能理解 1234567891011121314151617181920212223const Koa = require("koa");const app = new Koa();app.use(async (ctx,next) =&gt; &#123; console.log(1); setTimeout(()=&gt;&#123; next() console.log(2) &#125;,1000)&#125;);app.use(async (ctx,next) =&gt; &#123; console.log(3); next() console.log(4)&#125;);app.use(async (ctx,next) =&gt; &#123; console.log(5); setTimeout(()=&gt;&#123; console.log(6) &#125;,1000) next() console.log(7)&#125;);app.listen(3000); 访问 http://localhost:3000 输出123456713 // 1秒后开始输出57426 // 1秒后开始输出 不知道看到这你是否能够明白，不明白也没关系，我们可以深入源码来分析具体的实现 koa源码https://github.com/koajs/koa/blob/master/lib/application.js#L77 执行app.listen(3000);会走以下代码 123456789101112131415/** * Shorthand for: * * http.createServer(app.callback()).listen(...) * * @param &#123;Mixed&#125; ... * @return &#123;Server&#125; * @api public */listen(...args) &#123; debug('listen'); const server = http.createServer(this.callback()); return server.listen(...args);&#125;、 https://github.com/koajs/koa/blob/master/lib/application.js#L141我们接着看callback方法1234567891011121314151617181920/** * Return a request handler callback * for node's native http server. * * @return &#123;Function&#125; * @api public */callback() &#123; const fn = compose(this.middleware); if (!this.listenerCount('error')) this.on('error', this.onerror); const handleRequest = (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; return handleRequest;&#125; 在上面callback执行了compose方法来处理中间件，compose方法就是今天我们需要重点讲的方法，等会再说，我们知道Koa大部分情况都是在处理中间件，那么它们是怎么拿到中间件的呢？上面可以看到有一个this.middleware，中间件肯定是放在这里面的，于是我们搜索，在最上层可以在构造函数里看到初始化的时候，它把this.middleware = [];置为一个数组，我们使用中间件的时候是通过app.use来使用的。继续寻找use方法https://github.com/koajs/koa/blob/master/lib/application.js#L120use方法12345678910111213141516171819202122/** * Use the given middleware `fn`. * * Old-style middleware will be converted. * * @param &#123;Function&#125; fn * @return &#123;Application&#125; self * @api public */use(fn) &#123; if (typeof fn !== 'function') throw new TypeError('middleware must be a function!'); if (isGeneratorFunction(fn)) &#123; deprecate('Support for generators will be removed in v3. ' + 'See the documentation for examples of how to convert old middleware ' + 'https://github.com/koajs/koa/blob/master/docs/migration.md'); fn = convert(fn); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125; 每次我们调用app.use，koa都是把这个方法push到middleware数组里面。感觉说得有点啰嗦了，流程大体就是这样。 1定义中间件数组 -&gt; 收集中间件放到middleware数组里 -&gt; 通过compose方法处理中间件达到洋葱模式 koa-composehttps://github.com/koajs/compose/blob/master/index.js compose是引用的koa-compose包，查看源码发现关键只有20几行 123456789101112131415161718192021222324252627282930313233343536373839/** * Compose `middleware` returning * a fully valid middleware comprised * of all those which are passed. * * @param &#123;Array&#125; middleware * @return &#123;Function&#125; * @api public */function compose (middleware) &#123; if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) &#123; if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') &#125; /** * @param &#123;Object&#125; context * @return &#123;Promise&#125; * @api public */ return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 我们默许中间件传入的是数组函数，进一步剥离，精简的代码如下 123456789101112131415161718function compose (middleware) &#123; return function (context, next) &#123; let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; 初略的看，compose返回的是一个函数，首先执行了dispatch(0)，函数内容返回的都是Promise对象。最初执行dispatch(0)；通过递归的方式不断的运行中间件，每个中间件都接收了两个参数，分别是context和next，context其实就是koa的ctx，如果我们不传递next方法，后面的中间件就不会继续执行下去。 之前的代码我们可以初略的想象一下以下代码12345678910111213141516171819202122232425function fn1(context, next) &#123; console.log(1); next(); console.log(2);&#125;function fn2(context, next) &#123; console.log(3); next(); console.log(4);&#125;function fn3(context, next) &#123; console.log(5); next(); console.log(6);&#125;function compose() &#123; return fn1('', () =&gt; &#123; return fn2('', () =&gt; &#123; return fn3('', () =&gt; &#123; &#125;); &#125;); &#125;);&#125; 输出：123456135642 其实就是一层层嵌套执行中间件的方法，执行完next再往上执行 12345678910111213141516171819 ------------------------------------------------------------------------------------- | | | fn1 | | +-----------------------------------------------------------+ | | | | | | | fn2 | | | | +---------------------------------+ | | | | | | | | | | | fn3 | | | | | | | | |----------------------------------------------------------------------------------------------------&gt; | | | | | | | 1 | 3 | 5 6 | 4 | 2 | | | | | | | | | +---------------------------------+ | | | | | | | +-----------------------------------------------------------+ | | | +----------------------------------------------------------------------------------+ 最后koa-compose大致就这些，流程大致如洋葱一样，代码也不多，很好理解，以后使用中间件的时候就清晰很多了。 原文地址： http://wunci.github.io/2019/12/11/Koa源码系列之koa-compose/]]></content>
      <categories>
        <category>javascript</category>
        <category>Koa</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Koa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker快速入门]]></title>
    <url>%2F2019%2F12%2F03%2FDocker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是Docker？Docker 是一个开源的应用容器引擎，可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化 为什么要用Docker更高效的利用系统资源 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 一致的运行环境 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题 持续交付和部署 对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 更轻松的迁移 由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 更轻松的维护和扩展 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 对比传统虚拟机总结 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 以上摘自 https://yeasy.gitbooks.io/docker_practice/introduction/why.html 安装 注册账号 https://hub.docker.com/ 下载安装Docker mac安装地址 命令行输入 docker --version 查看当前 Docker 版本 镜像加速，鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决。Docker for mac 应用图标 -&gt; Perferences... -&gt; Daemon -&gt; Registry mirrors，在列表中填写加速器地址 http://hub-mirror.c.163.com。修改完成之后点击 Apply &amp; Restart 按钮。最后我们输入命令行 docker info 查看当前使用的镜像 实战我们先快速搭建一个web服务器命令行输入1docker run -p 80 --name web -it centos /bin/bash 然后安装 nginx12rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpmyum install -y nginx 安装完成可以通过命令whereis nginx查看安装路径，最后输入一下命令1nginx 最后我们执行 ctrl + P + Q 切换到后台，输入命令 docker ps -a 查看分配的端口号，我这里是端口号是32768 12CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES3db42e2903a0 centos &quot;/bin/bash&quot; About a minute ago Up About a minute 0.0.0.0:32768-&gt;80/tcp web 浏览器输入 http://localhost:32768 ，看到 Welcome to nginx 就算成功了 那么我们刚刚输入的一系列命令代表什么意思呢？ 我们输入docker run -p 80 --name web -it centos /bin/bash docker run表示运行一个新的容器，Docker 首先在本机中寻找该镜像，如果没有安装，Docker 在 Docker Hub 上查找该镜像并下载安装到本机，最后 Docker 创建一个新的容器并启动该程序 -i 选项是让容器标准输入打开，就可以接受键盘输入了 -t 选项是让docker分配一个伪终端，绑定到标准输入上。通过这个伪终端就可以像操作一台 linux 机器来操作这个容器了 --name &lt;容器名称&gt; 选项为容器指定一个名称，这里是web -p 80 告诉docker开放80端口 我们需要注意的是，docker run每次都会创建一个新的容器，如果需要操作之前创建的容器 重启容器1docker start web 进入容器1docker attach web 停止容器1docker stop web 镜像我们运行容器都需要镜像，上面我们使用到的的镜像是 centos 查看本地镜像1docker images 显示123456REPOSITORY TAG IMAGE ID CREATED SIZEnodejs latest 779742e01ba3 2 weeks ago 907MBnode latest 4ac0e1872789 5 weeks ago 933MBnginx latest 540a289bab6c 5 weeks ago 126MBnginx stable-alpine aaad4724567b 6 weeks ago 21.2MBcentos latest 0f3e07c0138f 2 months ago 220MB REPOSITORY：仓库名称。 TAG： 镜像标签，其中 lastest 表示最新版本。注意的是，一个镜像可以有多个标签，那么我们就可以通过标签来管理有用的版本和功能标签。 IMAGE ID ：镜像唯一ID。 CREATED ：创建时间。 SIZE ：镜像大小。 如果第一次我们通过 docker pull centos:latest 拉取镜像，那么当我们执行 docker run -p 80 --name web -it centos /bin/bash 时，它就不会再去远程获取了，因为本机中已经安装该镜像，所以 Docker 会直接创建一个新的容器并启动该程序。 事实上，镜像有很多，我们可以在 https://hub.docker.com 搜索仓库，输入框输入nginx，会出现很多nginx相关的镜像，我们也可以使用 docker search nginx 获取镜像列表1234567$ docker search nginxNAME DESCRIPTION STARS OFFICIAL AUTOMATEDnginx Official build of Nginx. 12284 [OK]jwilder/nginx-proxy Automated Nginx reverse proxy for docker con… 1696 [OK]richarvey/nginx-php-fpm Container running Nginx + PHP-FPM capable of… 746 [OK]...... 直接通过 docker pull nginx 就可以拉取镜像 构建自己的镜像要想构建自己的镜像，需要有一个Dockerfile文件，现在我们尝试把 node 程序 Docker 化 创建 Node.js 应用12345678910111213&#123; "name": "docker_web_app", "version": "1.0.0", "description": "Node.js on Docker", "author": "First Last &lt;first.last@example.com&gt;", "main": "server.js", "scripts": &#123; "start": "node server.js" &#125;, "dependencies": &#123; "express": "^4.16.1" &#125;&#125; 然后，创建一个 server.js 文件，使用 Express.js 框架定义一个 Web 应用12345678910111213141516'use strict';const express = require('express');// Constantsconst PORT = 8080;const HOST = '0.0.0.0';// Appconst app = express();app.get('/', (req, res) =&gt; &#123; res.send('Hello world\n');&#125;);app.listen(PORT, HOST);console.log(`Running on http://$&#123;HOST&#125;:$&#123;PORT&#125;`); Dockerfile创建一个空文件，命名为 Dockerfile1touch Dockerfile Dockerfile1234567891011121314151617181920# node版本为10的镜像FROM node:10# 应用程序工作目录WORKDIR /usr/src/app# 拷贝文件，有两种方法ADD、COPY，用法都一样，唯一不同的是 ADD 支持将归档文件（tar, gzip, bzip2, etc）做提取和解压操作# 注意的是，COPY 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。COPY package*.json ./# 执行命令RUN npm installCOPY . .# 暴露端口EXPOSE 8080# 执行命令 node server.jsCMD [ &quot;node&quot;, &quot;server.js&quot; ] .dockerignore 文件在 Dockerfile 的同一个文件夹中创建一个 .dockerignore 文件，带有以下内容12node_modulesnpm-debug.log 这将避免你的本地模块以及调试日志被拷贝进入到你的 Docker 镜像中，以至于把你镜像原有安装的模块给覆盖了 构建你的镜像构建需要一点时间1docker build -t wunci/node-web-app . 然后查看刚刚构建的镜像 1234docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEwunci/node-web-app latest 04fe1cd8e0b2 49 seconds ago 907MB 运行镜像1docker run -p 49160:8080 -d wunci/node-web-app 查看刚刚运行的容器123docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESffe453510350 wunci/node-web-app &quot;docker-entrypoint.s…&quot; 4 seconds ago Up 3 seconds 8081/tcp, 0.0.0.0:49160-&gt;8080/tcp unruffled_kare 查看容器内的log信息123docker logs CONTAINER ID打印出Running on http://0.0.0.0:8080 访问 http://0.0.0.0:8080 出现hello world 将镜像推送到远程仓库1docker push wunci/node-web-app:v1 格式为 docker push [OPTIONS] NAME[:TAG]，这里TAG为v1 总结至此简单入门的docker教程就全部结束了，我们首先安装docker -&gt; 创建容器 -&gt; 搜索拉取镜像 -&gt; 构建自己的镜像(Dockerfile) -&gt; 发布镜像，文章大部分其实参阅了各个平台的教程或者文档。简单的docker就这样跑起来了，但是真正我们去使用的时候往往会有很多问题，用法也不是直接这么暴力的去使用，例如直接拉取 centos 镜像往里面安装 nginx，会很浪费资源，也没有做到真正的隔离环境。下一篇讲使用docker-compose讲多个容器组合起来，尽可能实战操作 reference把一个 Node.js web 应用程序给 Docker 化30 分钟快速入门 Docker 教程Docker — 从入门到实践 本文地址： http://wunci.github.io/2019/12/03/Docker快速入门/]]></content>
      <categories>
        <category>Docker</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>教程</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab-CI初探]]></title>
    <url>%2F2019%2F10%2F16%2FGitlab-CI%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[因为项目一直都是使用gitlab进行自动化部署，但是都是前人种树，后人乘凉的现状。难得抽空花了一点时间来玩一下gitlab的CI 官方README 准备工作 一台服务器 注册gitlab账号，并且新建一个项目 新建.gitlab-ci.yml项目下新建文件 .gitlab-ci.yml，你也可以使用Web IDE 在线新建文件 安装Gitlab Runner到服务器登录你的服务器 123456# For Debian/Ubuntu$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash$ sudo apt-get install gitlab-ci-multi-runner# For CentOS$ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash$ sudo yum install gitlab-ci-multi-runner 接下来注册一个Runner 1sudo gitlab-runner register 然后会出现以下提示，我们直接输入 https://gitlab.com 12Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )https://gitlab.com 输入gitlab新建项目CI的token，token在项目内的 Setting -&gt; CI/CD -&gt; Runners（点击expand展开） 12Please enter the gitlab-ci token for this runner这里填token 输入runner的描述 12Please enter the gitlab-ci description for this runner这里随便填 命名tag 12Please enter the gitlab-ci tags for this runner (comma separated):my-tag // 每一个runner的唯一id，也可以在gitlab后台修改。 是否接收未指定 tags 的任务 12Whether to run untagged builds [true/false][false]: false 选择是否为当前项目锁定该 Runner 12Whether to lock Runner to current project [true/false]:[false]: false 选择 Runner executor 12345Please enter the executor: virtualbox, docker+machine, docker-ssh, shell, ssh, docker-ssh+machine, kubernetes, docker, parallels:shell // 这里选shell，很多人使用的是docker// 最后会告诉你注册成功Runner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded! 现在刷新一下之前复制token的地方看看，是不是刚刚新建的runner生效了 Pipeline一次 Pipeline 相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。我们的任何提交或者 Merge Request 的合并都可以触发 Pipeline。如下图：12345+------------------+ +----------------+| | trigger | || Commit / MR +----------&gt;+ Pipeline || | | |+------------------+ +----------------+ stagesstages表示构建阶段 所有 stages 会按照顺序运行，即当一个 stage 完成后，下一个 stage 才会开始 只有当所有 stages 完成后，该构建任务 (Pipeline) 才会成功 如果任何一个 stage 失败，那么后面的 stages 不会执行，该构建任务 (Pipeline) 失败 一个Pipeline会有多个Stage，一步步执行123456789+--------------------------------------------------------+| || Pipeline || || +-----------+ +------------+ +------------+ || | Stage 1 |----&gt;| Stage 2 |-----&gt;| Stage 3 | || +-----------+ +------------+ +------------+ || |+--------------------------------------------------------+ 配置.gitlab-ci.yml之前我们新建了.gitlab-ci.yml，那么我们来填写一些内容，让CI变得可用123456789101112131415161718192021stages: - build - test job2: stage: test script: - touch test.json only: - master tags: - my-tag job1: stage: build script: - npm init -y only: - master tags: - my-tag stages 就是我们上面讲的构建阶段，这里有两个阶段，先build然后test，会先执行任务 job1 然后 执行 job2，这里job1/2名称可用随便取，不影响 stage 表示构建的子任务 script 执行的shell命令 only 这里填写表示只有在master做操作的时候会触发这个构建 tags 这就是我们之前在服务器命名的tag，必填 我们把这个文件push到master，然后在 CI/CD -&gt; Pipelines 查看我们正在执行的任务 如果status显示passed了，则代表运行成功 至此，大功告成 更改执行用户你可能在上面一步会发现 npm not found的情况，但是服务器已经安装了node 因为gitlab-ci的runner默认使用gitlab-runner用户执行操作 通过指令ps aux|grep gitlab-runner可以看到： 1/usr/bin/gitlab-ci-multi-runner run --working-directory /home/gitlab-runner --config /etc/gitlab-runner/config.toml --service gitlab-runner --syslog --user gitlab-runner --working-directory：设置工作目录, 默认是/home/{执行user} --config：设置配置文件目录，默认是/etc/gitlab-runner/config.toml --user：设置执行用户名，默认是gitlab-runner 因此想要更改user为root只需要重新设置--user属性即可，步骤如下： 删除gitlab-runner 1sudo gitlab-runner uninstall 切换为root 1gitlab-runner install --working-directory /home/gitlab-runner --user root 重启gitlab-runner 1sudo service gitlab-runner restart 重新提交一下.gitlab-cli.yaml，应该就能够跑通了 原文地址： http://wunci.github.io/2019/10/16/Gitlab-CI初探/]]></content>
      <categories>
        <category>工具</category>
        <category>自动化</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue之vuex源码分析]]></title>
    <url>%2F2019%2F10%2F14%2FVue%E4%B9%8Bvuex%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[vuex使用当前vuex版本：3.1.0 12345678910111213141516171819202122import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const state = &#123; test: 1&#125;const actions = &#123; changeTest(&#123; commit &#125;, payload)&#123; commit('setTestValue', payload) &#125;&#125;const mutations = &#123; setTestValue(state, payload)&#123; state.test = payload &#125;&#125;export default new Vuex.Store(&#123; state, actions, mutations,&#125;) 123456789import Vue from 'vue';import store from './store';new Vue(&#123; el: '#app', store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;); 首先我们先注册vuex，然后设置一些state/mutation/actions 实例化出来，最后交给 Vue 处理 对 API 不熟悉的同学可以移步 vuex 注册用法我们知道了，那么问题来了，Vuex是怎样把store注入到Vue实例中去的呢？ 我们知道使用插件一般都需要vue.use()，传入的参数内部必须要提供一个install的方法，上面我们使用vue.use(vuex)去安装，那么vuex内部肯定是暴露了应该install的方法得 vuex install的实现 vuex/index.js 源码地址12345678910111213import &#123; Store, install &#125; from './store'import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from './helpers'export default &#123; Store, install, version: '__VERSION__', mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers&#125; install方法1234567891011121314export function install (_Vue) &#123; // 首先判断vuex是否已经注册过了 if (Vue &amp;&amp; _Vue === Vue) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error( '[vuex] already installed. Vue.use(Vuex) should be called only once.' ) &#125; return &#125; Vue = _Vue // 调用全局混入方法 applyMixin(Vue)&#125; 首先判断vuex是否被重复安装，安装完成之后调用applyMixin方法，内部方法见下文 applyMixin 源码地址1234567891011121314151617181920212223242526272829export default function (Vue) &#123; const version = Number(Vue.version.split('.')[0]) // 如果vue版本大于2 则调用全局混淆方法，混淆进beforeCreate钩子 if (version &gt;= 2) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;) &#125; else &#123; // 如果vue小于2版本，把vuexInit放入Vue的_init方法中执行 const _init = Vue.prototype._init Vue.prototype._init = function (options = &#123;&#125;) &#123; options.init = options.init ? [vuexInit].concat(options.init) : vuexInit _init.call(this, options) &#125; &#125; // Vuex的init钩子，会存入每一个Vue实例等钩子列表 function vuexInit () &#123; const options = this.$options // store injection if (options.store) &#123; this.$store = typeof options.store === 'function' ? options.store() : options.store &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123; this.$store = options.parent.$store &#125; &#125;&#125; 首先判断当前Vue的版本选择执行，大于2.0的版本直接把vuexInit混淆进beforeCreate，否则把vuexInit放入Vue的_init方法中执行。vuexInit会先从options中取store，如果当前组件为跟组件，那么options.store肯定会存在，把store挂载在vue的$store内，如果是非根组件，则获取options的parent，也就是父组件的$store，这样就实现了，所有的组件都获取到同一份地址的Store，那么现在我们来看看Store的实现 Store构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192export class Store &#123; constructor (options = &#123;&#125;) &#123; // 首先先安装Vue if (!Vue &amp;&amp; typeof window !== 'undefined' &amp;&amp; window.Vue) &#123; install(window.Vue) &#125; if (process.env.NODE_ENV !== 'production') &#123; // 判断vue是否安装 assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) // promise是否支持 assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`) // 判断this是否是Store的实例 assert(this instanceof Store, `store must be called with the new operator.`) &#125; // 一般options传入的是 /** * &#123; * state, * mutations, * actions, * modules * &#125; **/ const &#123; // store 上的插件方法 plugins = [], // 标记是否是严格模式，如果是严格模式，不允许直接修改state，一定要通过mutations strict = false &#125; = options // store internal state // 用来判断是否是mutations来修改的state this._committing = false // 存放action this._actions = Object.create(null) this._actionSubscribers = [] // 存放mutations this._mutations = Object.create(null) // 存放getter this._wrappedGetters = Object.create(null) // 存放module this._modules = new ModuleCollection(options) // 跟进命名空间存放module this._modulesNamespaceMap = Object.create(null) // 存放订阅者 this._subscribers = [] // 实现Vue的watch this._watcherVM = new Vue() // bind commit and dispatch to self const store = this const &#123; dispatch, commit &#125; = this // 把dispatch的this绑定到Store this.dispatch = function boundDispatch (type, payload) &#123; return dispatch.call(store, type, payload) &#125; // 把commit的this绑定到Store this.commit = function boundCommit (type, payload, options) &#123; return commit.call(store, type, payload, options) &#125; // strict mode // 是否为严格模式 this.strict = strict // 获取根模块的state const state = this._modules.root.state // init root module. // this also recursively registers all sub-modules // and collects all module getters inside this._wrappedGetters // 递归地注册传入的module installModule(this, state, [], this._modules.root) // initialize the store vm, which is responsible for the reactivity // (also registers _wrappedGetters as computed properties) // 通过vm重新设置store，等会看它的内部实现，原理是借助Vue的响应式来注册state和getter resetStoreVM(this, state) // apply plugins // 调用插件 plugins.forEach(plugin =&gt; plugin(this)) // devtool插件调用 const useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools if (useDevtools) &#123; devtoolPlugin(this) &#125; &#125;&#125; dispatch（action）我们知道如果我们需要改变state，需要先调用this.$store.dispatch()，来触发action，然后再调用commit来触发mutation，最终更改state，那么dispatch是怎么实现的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849dispatch (_type, _payload) &#123; // check object-style dispatch // 校验参数 const &#123; type, payload &#125; = unifyObjectStyle(_type, _payload) const action = &#123; type, payload &#125; // 获取当前需要触发action的函数集合，注意，这里entry是一个数组集合，一般来说是只会存在一个方法，type: function，至于为什么后面讲到 const entry = this._actions[type] if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown action type: $&#123;type&#125;`) &#125; return &#125; try &#123; // action 执行前，先调用订阅 action 变化的回调函数 this._actionSubscribers .filter(sub =&gt; sub.before) .forEach(sub =&gt; sub.before(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.warn(`[vuex] error in before action subscribers: `) console.error(e) &#125; &#125; // 如果集合大于1则调用Promise.all，全部resolve之后得到result，也是个promise对象，最后直接执行.then()方法返回执行的结果res const result = entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) return result.then(res =&gt; &#123; try &#123; // action 执行后，先调用订阅 action 变化的回调函数 this._actionSubscribers .filter(sub =&gt; sub.after) .forEach(sub =&gt; sub.after(action, this.state)) &#125; catch (e) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.warn(`[vuex] error in after action subscribers: `) console.error(e) &#125; &#125; return res &#125;)&#125; 上面代码可以看到我们使用Promise.all来执行entry，执行每个handle函数，全部执行完成后再.then()返回结果。那么这个handle是什么呢？ installModuleinstallModule内安装action12345678910111213function installModule (store, rootState, path, module, hot) &#123; ... module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) ...&#125; registerAction在Store构造函数内执行安装模块，内部会循环注册传入的action，调用registerAction方法 1234567891011121314151617181920212223242526272829function registerAction (store, type, handler, local) &#123; // 首先获取当前需要传入的action名字，如果没有则赋值为一个空对象，如果找到赋值给entry const entry = store._actions[type] || (store._actions[type] = []) // 往entry增加一个方法，也就是上面dispatch执行的handle // handle的this指向store，传入三个参数，&#123;dispatch,commit...&#125; (触发mutation需要使用，大部分只需要用到commit)，payload(外部传递进来的参数) cb（回调函数） entry.push(function wrappedActionHandler (payload, cb) &#123; let res = handler.call(store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload, cb) // 如果不是个promise，用promise包装一下返回 if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; // devtool插件相关 if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit('vuex:error', err) throw err &#125;) &#125; else &#123; return res &#125; &#125;)&#125; 我们一般是这么使用dispath的，👇12345this.$store.dispatch('actionName',&#123; test: 123&#125;).then((res=&gt;&#123; ...&#125;)) 再来想想dispatch的执行机制，是不是变得很清晰了？首先调用dispatch方法，获取需要调用的action，也是就actionName，然后把payload传入，也就是{test:1}，然后完成之后调用.then()异步执行所需操作 commit （mutation）先来看看实际应用是这么触发commit的12345678910const actions = &#123; changeTest(&#123; commit &#125;, payload)&#123; commit('setTestValue', payload) &#125;&#125;const mutations = &#123; setTestValue(state, payload)&#123; state.test = payload &#125;&#125; 在触发action的时候，调用commit，至于为什么会有commit方法，是因为上面registerAction push的方法第一个传输传入了一个对象{dispatch,commit...}，然后把dispatch传入的payload再代入commit方法捏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253commit (_type, _payload, _options) &#123; // check object-style commit // 校验参数 const &#123; type, payload, options &#125; = unifyObjectStyle(_type, _payload, _options) const mutation = &#123; type, payload &#125; // 获取当前对应的mutation方法集合 const entry = this._mutations[type] if (!entry) &#123; if (process.env.NODE_ENV !== 'production') &#123; console.error(`[vuex] unknown mutation type: $&#123;type&#125;`) &#125; return &#125; // 遍历调用集合内的方法，最后把payload参数传入集合的方法，等会介绍handle函数 // _withCommit方法是判断当前操作是否是通过commit提交来修改state的 this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;) &#125;) // 通知所有订阅者 this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== 'production' &amp;&amp; options &amp;&amp; options.silent ) &#123; console.warn( `[vuex] mutation type: $&#123;type&#125;. Silent option has been removed. ` + 'Use the filter functionality in the vue-devtools' ) &#125;&#125;``` ### installModule```jsfunction installModule (store, rootState, path, module, hot) &#123; ... module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) ...&#125; 和action同理，注册所有的mutation，调用registerMutation方法 registerMutation123456function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) entry.push(function wrappedMutationHandler (payload) &#123; handler.call(store, local.state, payload) &#125;)&#125; registerMutation方法比较简单，直接把state、payload传入handler函数 再来看看实际使用12345678910const actions = &#123; changeTest(&#123; commit &#125;, payload)&#123; commit('setTestValue', payload) &#125;&#125;const mutations = &#123; setTestValue(state, payload)&#123; state.test = payload &#125;&#125; commit调用之后，获取到对应需要触发的mutation，也就是setTestValue，然后实际执行的是registerMutation处理赋值给 store._mutations[&#39;setTestValue]的方法集合，也就是entry，内部会传入两个参数，state、payload,这就是我们可以直接使用 state.test = payload 的原因 mapState/mapAction/mapGetter等工具函数开发中我们经常会使用到mapState来获取数据工具函数源码地址 mapState先来看看我们在实际项目怎么使用12345678910111213141516171819202122232425// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;) // 或者带命名空间的使用，这就是下面normalizeNamespace得作用 computed: &#123; ...mapState('some/nested/module', &#123; a: state =&gt; state.a, // 如果不使用则需要通过 state.some.nested.module.a b: state =&gt; state.b &#125;)&#125;,&#125; mapState 源码地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 首先是判断是否使用了命名空间，如果没有的话namespace会被赋值为空，normalizeNamespace实现见代码底部export const mapState = normalizeNamespace((namespace, states) =&gt; &#123; const res = &#123;&#125; // 先把传入的states转换一下，转换例子如下，转换成数组对象的形式，都有key和val normalizeMap(states).forEach((&#123; key, val &#125;) =&gt; &#123; res[key] = function mappedState () &#123; // 获取state let state = this.$store.state let getters = this.$store.getters // 如果有命名则解析完成之后重新赋值state和getter if (namespace) &#123; // 通过模块来解析访问路径 some/nested/module =&gt; store._modulesNamespaceMap['some/nested/module/] = &#123; // 当前模块 &#125; // 关于如何实现的，源码地址 https://github.com/vuejs/vuex/blob/665455f8da/src/store.js#L301 const module = getModuleByNamespace(this.$store, 'mapState', namespace) if (!module) &#123; return &#125; state = module.context.state getters = module.context.getters &#125; // 如果传入的函数，则把state和getter传入到函数内 // 否则如果传入的是字符串，则直接取出返回数据，也就是上面使用 countAlias: 'count', return typeof val === 'function' ? val.call(this, state, getters) : state[val] &#125; // mark vuex getter for devtools res[key].vuex = true &#125;) // 最终把处理好的对象返回处理，所以可知mapState返回的是一个对象 return res&#125;)/** * Normalize the map * normalizeMap([1, 2, 3]) =&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ] * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) =&gt; [ &#123; key: 'a', val: 1 &#125;, &#123; key: 'b', val: 2 &#125;, &#123; key: 'c', val: 3 &#125; ] * @param &#123;Array|Object&#125; map * @return &#123;Object&#125; */function normalizeMap (map) &#123; return Array.isArray(map) ? map.map(key =&gt; (&#123; key, val: key &#125;)) : Object.keys(map).map(key =&gt; (&#123; key, val: map[key] &#125;))&#125;/** * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map. * @param &#123;Function&#125; fn * @return &#123;Function&#125; */function normalizeNamespace (fn) &#123; return (namespace, map) =&gt; &#123; // 首先判断第一个参数是否为字符串，因为我们大部分情况都是传递的是对象，只有使用命名空间的时候第一个参数会是字符串 // 如果不是字符串的话，把第一个参数也就是namespace赋值为map，自己置为空，这样就达到了第一个参数传入对象也是可以的 if (typeof namespace !== 'string') &#123; map = namespace namespace = '' // 如果传入的是对象，如果最后一个字符不是/，则自动拼接，因为 store._modulesNamespaceMap 下都是这样的key 'some/nested/module' // 具体怎么实现这种路径的见源码 getNamespace 方法 https://github.com/vuejs/vuex/blob/665455f8da/src/module/module-collection.js#L16 &#125; else if (namespace.charAt(namespace.length - 1) !== '/') &#123; namespace += '/' &#125; return fn(namespace, map) &#125;&#125; 这里只讲mapState，其他的实现大同小异，都差不太多 vuex响应式原理为什么我们通过修改state，模板里的视图也一起更新了呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function resetStoreVM (store, state, hot) &#123; const oldVm = store._vm // bind store public getters // 初始化store的getter store.getters = &#123;&#125; // 获取registerGetter方法注册的getter const wrappedGetters = store._wrappedGetters const computed = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; // use computed to leverage its lazy-caching mechanism // 因为getter的value都是函数，相当于vue的computed，这里直接执行获取结果 computed[key] = () =&gt; fn(store) // 通过Object.defineProperty为给个getter设置get方法，改变getter获取值方式，如this.$store.getter.a会直接获取store._vm.a Object.defineProperty(store.getters, key, &#123; get: () =&gt; store._vm[key], enumerable: true // for local getters &#125;) &#125;) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins // 先获取当前警告的配置 const silent = Vue.config.silent // 将他置为true，意思是new Vue的时候不会抛出警告 Vue.config.silent = true // 这里是关键，借助Vue的响应式来实现，这样state和getter的修改都会有响应式 store._vm = new Vue(&#123; data: &#123; $$state: state &#125;, computed &#125;) // new完之后恢复之前的配置 Vue.config.silent = silent // enable strict mode for new vm // 保证修改值一定是通过mutation的 if (store.strict) &#123; enableStrictMode(store) &#125; // 注销旧的state的引用，销毁旧的Vue对象 if (oldVm) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldVm._data.$$state = null &#125;) &#125; Vue.nextTick(() =&gt; oldVm.$destroy()) &#125;&#125; 从上面我们可以看到，vuex实现响应式，借助的是Vue的响应式，通过把store.state赋值给store._vm.$$state，这样修改state，同样store._vm.$$state也会被修改getter通过Object.defineProperty定义的get方法，访问的是store._vm.computed，让getter成为vue的计算实现，因此getter既拥有监听store._vm.$$state改变（并重新计算出自身的新值）的能力，又拥有在自身值改变之后通知外部watcher的能力 命名空间的副作用我们之前提到action和mutation对应的名称的值是一个数组，而不是直接的一个方法，正常应该下面这样👇12345const actionCollect = &#123; changeValue: (&#123; commit &#125;, payload))=&gt;&#123; ... &#125;&#125; 但是看源码我们知道，他是一个数组12345678910const actionCollect = &#123; changeValue: [ (&#123; commit &#125;, payload)=&gt;&#123; ... &#125; &#125; ,function()&#123;&#125; ... ] &#125; 难道action还有mutaion会有同名的吗？答案肯定是的，这就要讲到命名空间了namespace 123456789101112131415161718192021222324252627282930313233343536373839new Vuex.Store(&#123; state: &#123; a: 1 &#125;, modules: &#123; test1: &#123; namespaced: true, state: &#123; a: '2' &#125;, mutations: &#123; changeValue: (state, payload) =&gt; &#123; console.log('1') state.a = payload &#125; &#125; &#125;, test2: &#123; namespaced: false, state: &#123; a: '2' &#125;, modules: &#123; test1: &#123; namespaced: true, state: &#123; a: 3 &#125;, mutations: &#123; changeValue: (state, payload) =&gt; &#123; console.log('2') state.a = payload &#125; &#125; &#125; &#125; &#125; &#125;&#125;) 1234567export default &#123; name: 'App', mounted () &#123; this.$store.commit('test1/changeValue', 'the same value')&#125;// 输出：1// 输出：2 你会发现你commit了一次缺触发了两个不同模块的mutation，这就是命名空间的副作用，具体内部是如何处理namespace之前也讲到了，源码地址 1234567getNamespace (path) &#123; let module = this.root return path.reduce((namespace, key) =&gt; &#123; module = module.getChild(key) return namespace + (module.namespaced ? key + '/' : '') &#125;, '')&#125; 通过模块的key来拼接，如之前代码设置的namespace，namespace就是test1/changeValue 所以使用namespace一定要注意路径名问题，还是就是避免名称相同，除非你就想这么干 总结vuex源码就先讲这么多，其实还有好几个点没讲，例如各种工具方法和vue-devtools的实现，总体多读几遍还是可以看明白的，这就是debugger的过程了 原文地址 http://wunci.github.io/2019/10/14/Vue之vuex源码分析/]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>vue</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之编写一个loader]]></title>
    <url>%2F2019%2F07%2F05%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAloader%2F</url>
    <content type="text"><![CDATA[写在前面webpack的loader的应用是非常广泛的，完全离不开它，我们开发的过程往往都是使用别人编写好的loader来处理文件，今天我们就来编写一个loader。 基础首先我们看看loader是怎么使用在webpack上的 1234567891011module.exports = &#123; entry: '...', module: &#123; rules: [ &#123; test: /\.css$/, use: 'css-loader', &#125;, ], &#125;,&#125; 使用起来很简单，如果你需要处理css文件，那么安装好css-loader包，然后正则匹配到所有.css的文件，使用css-loader进行文件得处理 编写编写之前我们先给定个需求吧，设想我们能不能像vue那样编写，处理style/script/template，这样，我们先只处理style的内容，把他提取处理。 安装12&gt; npm init -y&gt; cnpm i webpack webpack-cli webpack-dev-server clean-webpack-plugin html-webpack-plugin -D 配置先来编写一个配置文件 新建文件 webpack.config.js12345678910111213141516171819202122const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js', &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;), ], module: &#123; rules: [ &#123; test: /\.css/, use: path.resolve(__dirname, 'loader/loader.js'), &#125;, ], &#125;,&#125;; 项目下新建src文件夹，src项目新建main.js、a.test文件 main.js12import './a.test';console.log('loader test'); a.test12345&lt;style&gt;body&#123; background: #ccc&#125;&lt;/style&gt; 我们重点是a.test文件，等会我会用loader处理他，让他显示到页面中 ———–分割线———– 现在我们在项目下新建loader文件夹，文件夹下面新建loader.js，这就是我们编写的loader loader/loader.js123456789101112module.exports = function(sSource) &#123; let sStyleString = sSource .match(/&lt;style&gt;([\s\S]*)&lt;\/style&gt;/)[1] .replace(/\n/g, ''); return ` let head = document.querySelector('head'); let style = document.createElement('style'); style.type = 'text/css'; let cssNode = document.createTextNode('$&#123;sStyleString&#125;'); style.appendChild(cssNode); head.appendChild(style);`;&#125;; 没错，就这么多，loader接收一个参数，也就是sSource，内容就是.test后缀下的文件内容，我们只需要获取内容，然后做我们想做的一切事情，比如，我提取了文件里css的部分，像.vue那样，然后去写一段js，把这段css通过&lt;style&gt;&lt;/style&gt;的方式放到页面上去 现在你运行一下这个项目，然后查看浏览器，浏览器的背景是否变了颜色？ apiloader的上下文通过this访问，举几个例子 this.query 如果这个 loader 配置了 options 对象的话，this.query 就指向这个 option 对象 如果 loader 中没有 options，而是以 query 字符串作为参数调用时，this.query 就是一个以 ? 开头的字符串 this.context模块所在的目录 this.emitFile1emitFile(name: string, content: Buffer|string, sourceMap: &#123;...&#125;) 可以通过用它来生成一个文件 总结写一个loader很简单，只需要你有对文件内容处理的能力，还是很容易上手的，关键不在loader，而在于你的需求复杂程度 本文地址 webpack系列之编写一个loader]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之编写一个plugin]]></title>
    <url>%2F2019%2F06%2F21%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAplugin%2F</url>
    <content type="text"><![CDATA[写在前面使用webpack或者自己配置研究过webpack的人都知道plugin，也就是webpack的插件，对于大多数人来说，经常使用的插件诸如：clean-webpack-plugin、html-webpack-plugin等等，在很多情况下，我们只会去用它，知道他是干什么的，但是其内部做的操作缺知之甚少，今天我们就来写一个plugin 基础首先我们看看插件是怎么使用在webpack上的 123456789101112const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: '...', plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: './index.html', &#125;), ] &#125; 我们经常使用的插件是长这样的，每个插件都是一个构造函数，通过new一个它的实例来使用。知道了插件是一个构造函数，那么我们可以推断出下面的结构123class TestPlguin&#123; ...&#125; webpack 插件由以下组成： 一个 JavaScript 命名函数。 在插件函数的 prototype 上定义一个 apply 方法。 指定一个绑定到 webpack 自身的事件钩子。 处理 webpack 内部实例的特定数据。 功能完成后调用 webpack 提供的回调。 12345678910111213class TestPlguin &#123; constructor()&#123; &#125; apply(compiler)&#123; compiler.plugin('webpacksEventHook', function(compilation /* 处理 webpack 内部实例的特定数据。*/, callback) &#123; console.log("This is an example plugin!!!"); // 功能完成后调用 webpack 提供的回调。 callback(); &#125;); &#125;&#125; 上面是官网上的示例，插件一定会有apply方法，传递一个compiler参数，通过 CLI 或 Node API 传递的所有选项，创建出一个 compilation 实例。 在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。理解它们的角色是扩展 webpack 引擎重要的第一步。 compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。 compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。 Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译 钩子Compiler和Compilation都有生命周期 Compiler举几个例子 entryOption：在 entry 配置项处理过之后，执行插件 emit：生成资源到 output 目录之前。 failed：编译(compilation)失败 12345678class TestPlguin &#123; ... apply(compiler)&#123; compiler.hooks.emit.tap('MyPlugin', params =&gt; &#123; console.log('我会在生成资源到 output 目录之前执行') &#125;) &#125;&#125; 上面的例子意思是，当webpack执行到最终要输出文件得时候，我在这个操作之前去打印一段话，通常是我们输出文件到dist文件夹之前那一步如果你实现写好了这些钩子，那么webpack在编译的流程里都会执行上面几个钩子。想了解更多访问 https://www.webpackjs.com/api/compiler-hooks/ CompilationCompilation 模块会被 Compiler 用来创建新的编译（或新的构建）。compilation实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。它会对应用程序的依赖图中所有模块进行字面上的编译(literal compilation)。在编译阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored) 简单的理解就是，当编译期间文件发生各种变化的时候，我们可以通过 Compilation 钩子里的生命周期函数去拦截，然后做你想做的事情 举几个例子 buildModule：在模块构建开始之前触发。 optimize：优化阶段开始时触发。 beforeChunkAssets：在创建 chunk 资源(asset)之前 additionalAssets：为编译(compilation)创建附加资源(asset) 123456789101112class TestPlguin &#123; ... apply(compiler)&#123; compiler.hooks.emit.tap('MyPlugin', compilation =&gt; &#123; console.log('我会在生成资源到 output 目录之前执行') // 以下开始调用compilation钩子，当模块处在优化阶段开始时会执行以下回调 compilation.plugin("optimize", function() &#123; console.log("我在优化阶段开始时触发了"); &#125;); &#125;) &#125;&#125; 想了解更多访问 https://www.webpackjs.com/api/compilation-hooks/ 编写插件我们现在假定有一个这么个需求：我需要在打包的时候把一个外部的js文件导入到项目中，并且在index.html引入，你可能会问了，那你直接在主入口引入不就行了吗？确实，感觉做这件事情很没有意义，但是我就要这个需求，原因在于我在使用DllPlugin的时候，提前生成好了一堆文件，这些文件是不会在正常打包的过程引入的，所以我需要在最后打包生成文件之前把他们导入到dist文件夹下，并且引入他们。 那么我们现在开始编写，先写个简单的，一个文件的导入，抛砖引玉。 首先我们思考一下🤔，这个插件得有配置呀，和html-webpack-plugin一样可以传参数 12345678module.exports = &#123; plugin: [ new TestPlugin(&#123; filename: 'test.js', template: path.resolve(__dirname, './otherFile/test.js'), &#125;), ]&#125; 我们在项目里新建文件夹plugin，文件夹下新建TestPlugin.js。然后在项目里再新建文件夹otherFile，文件夹下新建test.js，这里文件内容随便 上面我们说了需要传递参数，所以有了下面这段js，options是我们传递的对象，apply就不多说了，每个插件都有这个方法，然后我们把这个插件暴露出来TestPlugin.js123456789class TestPlugin &#123; constructor(options = &#123;&#125;) &#123; this.options = options; &#125; apply(compiler) &#123; &#125;&#125;module.exports = TestPlugin; 接下来我们开始写内部方法 我们又要思考一下，我需要在打包完成之前做这个操作，那么compiler钩子的生命周期函数是哪个呢？没错，是emit，之前讲过，于是乎有了下面这段jsTestPlugin.js1234567891011class TestPlugin &#123; constructor(options = &#123;&#125;) &#123; this.options = options; &#125; apply(compiler) &#123; compiler.hooks.emit.tapAsync('TestPlugin', (compilation, callback) =&gt; &#123; callback(); &#125;); &#125;&#125;module.exports = TestPlugin; 上面代码，我们注册了一个emit，webpack在执行打包的最后，会触发这个内部得方法 接下来就是对文件得处理了，需要用到compilation 我们思考一下，怎么处理文件？我们需要用到compilation下的asset，来处理资源文件。我们先把文件导入到dist文件夹下，于是乎有了下面这段jsTestPlugin.js1234567891011121314151617181920212223const fs = require('fs');class TestPlugin &#123; constructor(options = &#123;&#125;) &#123; this.options = options; &#125; apply(compiler) &#123; compiler.hooks.emit.tapAsync('TestPlugin', (compilation, callback) =&gt; &#123; let template = fs.readFileSync(this.options.template, 'UTF-8'); compilation.assets[this.options.filename || 'test.js'] = &#123; source: function() &#123; return template; &#125;, size: function() &#123; return template.length; &#125;, &#125;; callback(); &#125;); &#125;&#125;module.exports = TestPlugin; 上面代码，我们读取了插件实例传递过来的参数filename，调用compilation钩子下的assets，这个assets是一个键值对的形式，key是资源文件得名称，value是资源文件的内容，也是一个对象。执行compilation.assets，如果键值是一个已经存在的文件，webpack不会帮你重新创建，你可以去尝试修改一个文件 好了，文件导入了，但是我们还需要在index.html去引入这个文件，思考一下，这个index.html是已经存在的，我们同样可以使用compilation.assets去修改它的文件内容，所以有了下面这段js TestPlugin.js123456789101112131415161718192021222324252627282930313233343536373839const fs = require('fs');class TestPlugin &#123; constructor(options = &#123;&#125;) &#123; this.options = options; &#125; apply(compiler) &#123; compiler.hooks.emit.tapAsync('TestPlugin', (compilation, callback) =&gt; &#123; let template = fs.readFileSync(this.options.template, 'UTF-8'); compilation.assets[this.options.filename || 'test.js'] = &#123; source: function() &#123; return template; &#125;, size: function() &#123; return template.length; &#125;, &#125;; // 这里是新加的 let source = compilation.assets['index.html'].source(); source = source.replace( /&lt;\/(.*?)&gt;(.*?)&lt;\/body&gt;$/m, `&lt;/$1&gt;&lt;script src="$&#123;this.options.filename || 'test.js'&#125;"&gt;&lt;/script&gt;&lt;/body&gt;`, ); compilation.assets['index.html'] = &#123; source: function() &#123; return source; &#125;, size: function() &#123; return source.length; &#125;, &#125;; callback(); &#125;); &#125;&#125;module.exports = TestPlugin; 我们通过修改文件的source，把一段script插入到body之前来修改文件 插件写好了，我们在webpack去引入吧 12345678910111213141516171819202122const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const TestPlugin = require('./plugin/TestPlugin');module.exports = &#123; mode: 'production', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;), new TestPlugin(&#123; filename: 'test.js', template: path.resolve(__dirname, './otherFile/test.js'), &#125;), ],&#125;; 打包运行一下，看看效果吧 插件代码仓库：https://github.com/wunci/webpack-plugin 总结今天我们学习了一如何编写一个插件，当然只是简单的操作了，可以思考一下，要实现clean-webpack-plugin或者html-webpack-plugin插件，我们该怎么做？ 本文地址 webpack系列之编写一个plugin]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之输出文件分析]]></title>
    <url>%2F2019%2F06%2F19%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[写在前面上一篇文章我们讲了如何使用 webpack，执行打包会在 dist 生成一堆文件，那么 webpack 输出的文件里面到底长啥样呢？用过的人100%看过，大部分的还是压缩混淆后的代码，一般我们不会去关心它，只管当前持续运行正常就行了。今天我们来看看 webpack 输出的文件 配置安装开发环境 webpack: 4.34.0 12&gt; npm init -y&gt; cnpm i webpack webpack-cli -D 新建文件新建文件 webpack.config.js新建文件夹 srcwebpack.config.js12345678910const path = require('path');module.exports = &#123; devtool: 'inline-source-map', mode: 'development', entry: './src/main.js', output: &#123; path: path.resolve(__dirname, './dist'), filename: 'bundle.js', &#125;,&#125;; src 文件夹下，新增三个文件 main.js（入口文件） a.js b.jsmain.js1234import &#123; A1, A2 &#125; from './a';import B from './b';console.log(A1, A2);B(); a.js12export const A1 = 'a1';export const A2 = 'a2'; b.js123export default function() &#123; console.log('b');&#125; 打包1npx webpack --config webpack.config.js 然后就会在 dist 下生成一个 bundle.js 文件，接下来开始分析文件 文件分析首先先来看看大致的结果1234567891011(function(modules) &#123; function __webpack_require__(moduleId) &#123; ... &#125; ... return __webpack_require__(__webpack_require__.s = "./src/main.js");&#125;)(&#123; "./src/a.js": (function(module, __webpack_exports__, __webpack_require__) &#123;&#125; "./src/b.js": (function(module, __webpack_exports__, __webpack_require__) &#123;&#125; "./src/main.js": (function(module, __webpack_exports__, __webpack_require__) &#123;&#125;&#125;) 从上面我们可以看到一个立即执行的函数，传递了一个对象，也就是 modules 的值，最终执行了 __webpack_require__ 函数，执行的这个方法其实是我们在 webpack 里面设置的 entry: ./src/main.js，对象里还有key，./src/a.js 、./src/b.js，也就是我们的 a.js 和 b.js 我们知道最开始执行了 __webpack_require__(__webpack_require__.s = &quot;./src/main.js&quot;) 方法，也就是 __webpack_require__(&quot;./src/main.js&quot;)，那么这个 __webpack_require__ 方法又做了什么的 原始的 __webpack_require__ 方法1234567891011121314151617181920// The module cachevar installedModules = &#123;&#125;;function __webpack_require__(moduleId) &#123; // Check if module is in cache if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // Create a new module (and put it into the cache) var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // Flag the module as loaded module.l = true; // Return the exports of the module return module.exports;&#125; 现在我在这上面写上注释12345678910111213141516171819202122232425// 模块缓存var installedModules = &#123;&#125;;function __webpack_require__(moduleId) &#123; // 首先全局有一个模块对象，最先判断是否存在这个模块，是否做过相应操作，如果有则直接返回当前模块的一个对象，这里的exports其实就是一个对象 if(installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; // 这里就直接创建了一个模块，并且缓存在全局的模块中，这里重点关注这个exports， // i 指的是模块的名称，比如 './src/main.js' // l 意思是当前模块是否加载 // exports 就是返回出去的对象内容 var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // 到这里就开始通过key去执行 modules（就是刚开始立即执行函数传过来的对象）对象的方法 // 然后使用call来指向 对象的方法 的this，并且把 module, module.exports, __webpack_require__ 三个值传过去， // 这里先做预告，module这个参数传过去其实是没有用到的，主要使用 module.exports 对象, 以及__webpack_require__方法 modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); // 上面说到有一个参数 l，到这里当前模块已经加载 module.l = true; // 最后把module.exports这个模块返回出去 return module.exports;&#125; 接下来我们看看主入口 ./src/main.js 这个 key 的值的内容 ./src/main.js，原内容是这样的，接下来来解释一下123456789101112&#123; "./src/main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; "use strict"; __webpack_require__.r(__webpack_exports__); /* harmony import */ var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ "./src/a.js"); /* harmony import */ var _b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b */ "./src/b.js"); console.log(_a__WEBPACK_IMPORTED_MODULE_0__["A1"], _a__WEBPACK_IMPORTED_MODULE_0__["A2"]); Object(_b__WEBPACK_IMPORTED_MODULE_1__["default"])(); &#125;)&#125; 1234567891011121314151617&#123; "./src/main.js": (function(module, __webpack_exports__, __webpack_require__) &#123; // 上面我们说到 __webpack_require__ 方法内部会执行 modules[moduleId].call，并传递了三个参数，那么他执行的方法就是这个内部方法 // 这段代码可以先忽略，在当前项目没有作用 __webpack_require__.r(__webpack_exports__); // 我们看到下面有两段__webpack_require__函数代码的执行，你可以回顾一下main.js的内容，我们是不是做了 import &#123; A1, A2 &#125; from './a';并且 console.log(A1, A2); /* harmony import */ var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ "./src/a.js"); /* harmony import */ var _b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b */ "./src/b.js"); console.log(_a__WEBPACK_IMPORTED_MODULE_0__["A1"], _a__WEBPACK_IMPORTED_MODULE_0__["A2"]); // 这段代码其实是 import B from './b'; B();代码的执行 Object(_b__WEBPACK_IMPORTED_MODULE_1__["default"])(); &#125;)&#125; 好了，现在来分析一下 __webpack_require__(&quot;./src/a.js&quot;) 做了哪些操作，我们先来看看 模块./src/a.js 的内容./src/a.js123456789&#123; "./src/a.js": (function(module, __webpack_exports__, __webpack_require__) &#123; __webpack_require__.r(__webpack_exports__); /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A1", function() &#123; return A1; &#125;); /* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "A2", function() &#123; return A2; &#125;); const A1 = 'a1'; const A2 = 'a2'; &#125;),&#125; 代码内容很简单，首先 __webpack_require__(&quot;./src/a.js&quot;) 执行之后，会创建一个模块，然后去执行模块 ./src/a.js 内部得方法，也是是上面这段，执行完成之后最终会把 module.exports 返回处理，那么 module.exports 这个是什么内容呢？看看 webpack_require 内部12345678var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; // Execute the module function modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); return module.exports 其实就是我们创建模块时的 exports，然后执行到了模块 ./src/a.js 内部得方法，它内部方法关键的地方在于又调用了 __webpack_require__.d 方法 __webpack_require__.d12345__webpack_require__.d = function(exports, name, getter) &#123; if(!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125;&#125;; 执行 __webpack_require__.d(__webpack_exports__, &quot;A1&quot;, function() { return A1; }); 可以看出来他给 module.exports 定义了一个 key 值 &quot;key&quot;，然后取值 get 的时候返回的是 A1(也就是a1) 所以最终 return module.exports 的值为 {A1: &#39;a1&#39;}， 我们回到 ./src/main.js 模块，所以这段代码：var _a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./a */ &quot;./src/a.js&quot;); _a__WEBPACK_IMPORTED_MODULE_0__ 其实就是等于 {A1: &#39;a1&#39;} console.log(_a__WEBPACK_IMPORTED_MODULE_0__[&quot;A1&quot;])，取值为 a1，A2 同理 接下来我们看看模块 ./src/b.js，在主模块它做了什么呢？看看 ./src/main.js 123...var _b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b */ "./src/b.js");Object(_b__WEBPACK_IMPORTED_MODULE_1__["default"])(); 看上面模块 ./src/b.js 在主模块的执行第一段代码和之前介绍的一样，第二段代码直接执行了一个方法，这里我们可以猜测出 _b__WEBPACK_IMPORTED_MODULE_1__ 其实就是一个对象，访问了它的 key: default然后它的key值其实是一个函数，最后执行了这个函数 同理我们可以看看模块 ./src/b.js 内部的方法，以及我们在 src 文件夹下的 b.js 是怎么写的模块 ./src/b.js1234567&#123; "./src/b.js": (function(module, __webpack_exports__, __webpack_require__) &#123; __webpack_require__.r(__webpack_exports__); /* harmony default export */ __webpack_exports__["default"] = (function() &#123; console.log('b'); &#125;);&#125; b.js123export default function() &#123; console.log('b');&#125; 从我们源代码看出，我们是直接导出了一个方法，内部执行了打印字符串b，然后再来看看 webapck 的源码部分，__webpack_require__.r(__webpack_exports__); 这段可以忽略，解释一下，其实这段代码在对象里定义了一个 __esModule: true，接着看下面一段，我们从之前讲的知道知道 __webpack_exports__ 其实就是一个单纯的空对象（其实不是，执行了 __webpack_require__.r(__webpack_exports__ )就变成了 {__esModule: true})，然后它又在对象里增加了一个 default 属性，然后把一个方法赋值给它(其实就是我们打包之前写的一个方法)，最终在主入口里执行的模块 var _b__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b */ &quot;./src/b.js&quot;)；其实就等于 {&quot;default&quot;: function{}}，然后下一步执行访问对象 default 的值去执行函数 思考可能现在你可能会思考🤔，通过上面的比较可以得出一个结论 通过 export 出来，如果 import {a,b,c} from &#39;..&#39;，打包出来的代码执行简单操作之后（执行 __webpack_require__ 函数）首先会是一个对象，对象会是 {a: ..., b: ..., c: ...} 同过 export default 出来，如果 import a from &#39;..&#39;，打包处理的代码执行简单操作之后（执行 __webpack_require__ 函数）首先会是一个对象，然后会往对象里添加一个default的key，类似 {default: ...} 总结整个过程还是挺绕的，你可以自己去 debugger 看看他的执行过程，应该就明白得差不多了，今天就讲了这些吧 本文地址 webpack系列之输出文件分析]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack系列之初探]]></title>
    <url>%2F2019%2F06%2F06%2Fwebpack%E7%B3%BB%E5%88%97%E4%B9%8B%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[写在前面相信webpack这个名称对于前端的同学来说并不陌生，只要你在用vue、react等等之类的框架，就得天天和它打交道。但是大部分人都只是直接怼一个vue-cli脚手架生成一个项目，运行起来就开始一顿写，完全不会去看这个项目的其他相关的东西，今天开始，咱们就来说说这个又爱又恨的webpack 问题使用wepack的时候经常会出现下面这些疑问 你webpack只能打包单页面的文件吗？ WTF，我包怎么这么大，加载太慢了 我打包速度怎么这么慢，什么破玩意？… 为什么要使用webpack哈，你问我为什么要用？因为大家都在用啊😃😃。开个玩笑，前端发展到今天，新技术新思想新框架爆发式增长，当前的浏览器环境跑不赢啊，你说你写个ES6/7在浏览器环境都能跑起来？扯淡的。这个时候babel就出现了，你跑不起来是吧，那我转成ES5你总该跑起来吧~，那babel我还是不能直接用啊，肯定得借助工具编译呀，所以我们需要webpack去做这件事情了。这个时候有人就要站出来说了，我gulp不服，我也能做，我就不用webpack。你这么说我就要跟你唠唠了，现在我们先来比较一下webpack和gulp。 gulp 是 task runner，Webpack 是 module bundler webpack的优势在模块化，gulp除了模块化方面都很不错。但是前端发展至今，模块化真的很重要，CMD、AMD就是模块化的产物。简单来说，如果你当前项目需要模块化编程，那就选webpack，如果是处理其他事情，比如把图片拼接成雪碧图或者压缩，那么gulp是最擅长的 感兴趣的可以看看这个回答 gulp 有哪些功能是 webpack 不能替代的？ 安装这里可以参考webpack官网开发环境 webpack: 4.34.0123&gt; mkdir webpack &amp;&amp; cd webpack&gt; npm init -y&gt; npm install webpack webpack-cli -D 入口（entry）每个webpack都会有一个entry，就是入口的意思，指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 注意点： 入口可以有多个，如果是单页面只需要一个入口，多页面可以设置多个入口 入口的文件必须是.js文件，因为webpack只认识js（不完全对，其实任意文件都可以，只是webpack会把它当做js来处理） 举个🌰我们新建webpack.config.js和新建src文件夹，并且文件夹下新建index.js文件目录如下 1234- webpack/- src/- index.js- webpack.config.js webpack.config.js123module.exports = &#123; entry: './src/index.js'&#125;; 我们上面指定webpack的入口文件为index.js文件，这是总入口 出口（output）有入口当然就会有出口了，就是你导出的文件 webpack.config.js1234567module.exports = &#123; entry: './src/index.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 上述entry已经介绍过了，我们来看看output，他有文件导出的路径（path）和导出的文件名（filename） 关于filename这里需要注意的地方有： 出口的文件名可以定制化，当前如果你是单页面的话，简单的可以写死一个filename，就如上面的bundle.js一样 你也可以这么写，使用入口名称的名称：filename: &#39;[name].bundle.js&#39;,当然还需要改一下entry，把它改成以下形式，name就会变成 -&gt; app 123456789module.exports = &#123; entry: &#123; app: './src/index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;&#125;; 现在我们来试一下webapck打包 小试牛刀第一步，新建一个文件夹webpack-demo123&gt; mkdir webpack-demo &amp;&amp; cd webpack-demo&gt; npm init -y&gt; cnpm install webpack webpack-cli -D 第二步，新建src/index.js文件和webpack.config.js文件 webpack.config.js 12345678const path = require('path');module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; index.js1document.write('hello webpack'); 第三步，打包命令行输入1&gt; npx webpack --config webpack.config.js 然后控制台就会输出12345678Hash: 348dca17387cd3f29cefVersion: webpack 4.33.0Time: 227msBuilt at: 2019-06-08 15:24:07 Asset Size Chunks Chunk Namesbundle.js 961 bytes 0 [emitted] mainEntrypoint main = bundle.js[0] ./src/index.js 33 bytes &#123;0&#125; [built] 看到这个信息证明你已经大功告成了，去看看dist/文件夹下是不是有打包好的js文件最后面你会看到有黄色的警告，说mode没有设置，待会再讲 这个时候你就会想，我每次生成的文件都叫bundle.js，我都区分不开，也不好做缓存，这个时候你就需要配置一下filename了 我们把webpack.config.js改成以下 12345678910const path = require('path');module.exports = &#123; entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; 然后执行1&gt; npx webpack --config webpack.config.js 这个时候dist/文件夹下就会多出个类似app.32434c7cc602e3049dac.js的文件，而且如果你反复执行打包命令，你发现app.32434c7cc602e3049dac.js文件名都没有改变，这是为什么呢？因为webpack会判断你的文件是否有更改而来觉得文件夹hash的变更，现在你可以尝试修改一下index.js文件之后打包的效果就知道了。 模式（mode ）上面说到每次打包的时候都会报警告，告诉我们没有设置mode，现在我们来说说mode首先mode有两个值，分别是development和production，意思就是，当前项目打包的开发环境还是生成环境的代码如果你设置了mode: ‘development’，在项目里你可以使用 process.env.NODE_ENV 来获取当前的环境的值你可以尝试把webpack.config.js改成以下，然后在index.js里把这个值打印出来，运行一下效果 webpack.config.js1234567891011const path = require('path');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;,&#125;; index.js1document.write(`hello webpack，this is $&#123;process.env.NODE_ENV&#125;`); 现在我们只有js文件，你可以先在根目录新建一个index.html文件，把js引入在浏览器环境执行(或者直接在浏览器控制台执行js)，你会看到浏览器显示 -&gt; hello webpack，this is development你分别运行之后会发现他们的效果是不一样的，一个是被压缩的，一个没有被压缩 这个时候你就会想了，怎么这么麻烦，我打包还得自己去新建html文件引入js然后运行或者去执行js文件，能不能让他自动运行跑起来？当然是可以的，下面我们来说说plugins## 插件（plugins）插件是 webpack 的支柱功能。webpack 自身也是构建于，你在 webpack 配置中用到的相同的插件系统之上！（官网的解释）插件怎么说呢？不好解释它，你可以理解为处理工具，插件目的在于解决 loader(这个等会再讲，现在用不上) 无法实现的其他事插件怎么配置？就像下面这样，当然不是随便找的插件，我们会用到下面配置的插件123456789101112131415const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: 'index.html'&#125;) ]&#125;;我们先在根目录新建一个index.html文件，之前不是说运行项目很麻烦嘛？现在教你简单的方法然后我们用到了html-webpack-plugin，需要先安装他才能使用1&gt; cnpm i html-webpack-plugin -D下一步打包运行项目1&gt; npx webpack --config webpack.config.js运行结果：12345678910111213141516Hash: bea857ae13cad8af6e66Version: webpack 4.33.0Time: 274msBuilt at: 2019-06-08 16:00:33 Asset Size Chunks Chunk Namesapp.bea857ae13cad8af6e66.js 3.83 KiB app [emitted] app index.html 74 bytes [emitted] Entrypoint app = app.bea857ae13cad8af6e66.js[./src/index.js] 65 bytes &#123;app&#125; [built]Child html-webpack-plugin for &quot;index.html&quot;: 1 asset Entrypoint undefined = index.html [./node_modules/_html-webpack-plugin@3.2.0@html-webpack-plugin/lib/loader.js!./index.html] 209 bytes &#123;0&#125; [built] [./node_modules/_webpack@4.33.0@webpack/buildin/global.js] (webpack)/buildin/global.js 472 bytes &#123;0&#125; [built] [./node_modules/_webpack@4.33.0@webpack/buildin/module.js] (webpack)/buildin/module.js 497 bytes &#123;0&#125; [built] + 1 hidden module去查看dist文件夹下，你会发现多出了两个文件，js和index.html文件，这就是插件的功劳html-webpack-plugin这个插件需要指定是那个html模板，然后最后打包的时候就是以这个模板为主，把打包好的js文件放到这个index.html里面，你可以查看html文件里的内容：index.html1&lt;script type="text/javascript" src="app.1b0b2001b0579faec32d.js"&gt;&lt;/script&gt;这个时候你会发现，我靠，我dist文件怎么这么多啊，怎么办啊？别急，我们再来用一个插件解决这个问题 安装插件clean-webpack-plugin1&gt; cnpm i clean-webpack-plugin -D 然后配置文件去添加插件 1234567891011121314151617const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123;template: 'index.html'&#125;) ]&#125;; 然后你再去看看dist文件夹里的文件，是不是只有两个文件了？这个插件的作用是，先把dist文件夹里的文件先清空然后再把打包好的文件放入dist。 那么你还会有问题，这还是麻烦啊，我不能只运行命令行，让重新自己打开浏览器运行我打包的项目吗？当然可以啊首先安装 webpack-dev-server1&gt; cnpm i webpack-dev-server -D然后1&gt; webpack-dev-server --open --config webpack.config.js你会发现重新自动打开了浏览器，页面显示 hello webpack，this is development。是不是很简单？你现在可以去修改index.js然后保存文件，去浏览器看看是不是自动刷新了你刚刚更改的内容呢？现在你可能还会有问题，我去，这太简单了吧，我要用css和图片怎么办？js不能导入css文件啊！我怎么跟vue一样在自己的ip访问项目啊？现在肯定是问题一大堆 loaderloader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。比如可以把typescript转换成JavaScript，less转成css现在我们就来解决你上一章节末的问题，教你配置简单的loader，来加载css或者图片首先我们先安装css-loader/style-loader，来加载解析css文件1&gt; cnpm i css-loader style-loader -D 下一步在src文件夹下新建test.css文件，再在index.js导入test.css123body &#123; background: #ccc;&#125; index.js12import './test.css';document.write(`hello webpack，this is $&#123;process.env.NODE_ENV&#125;，test`); 如果你直接运行会发现控制台报错了1234567ERROR in ./src/test.css 1:5Module parse failed: Unexpected token (1:5)You may need an appropriate loader to handle this file type.&gt; body &#123;| background: #ccc;| &#125; @ ./src/index.js 1:0-20 这个时候loader登场了，我们修改配置文件webpack.config.js12345678910111213141516171819202122232425const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');module.exports = &#123; mode: 'development', entry: &#123; app: './src/index.js', &#125;, output: &#123; filename: '[name].[hash].js', path: path.resolve(__dirname, 'dist/'), &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: 'index.html' &#125;), ], module: &#123; rules:[ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], &#125;, ] &#125;&#125;; 然后运行命令行1&gt; webpack-dev-server --open --config webpack.config.js 你会发现页面背景颜色变了 现在我们来说说配置：module.rules 允许你在 webpack 配置中指定多个 loader，上面我们规定正则匹配css文件，然后如果匹配到了，则使用style-laoder和css-loader去处理css文件，css-laoder负责解析css文件，style-loader负责把css文件放到页面中去，你打开调试可以看到head里被插入了style样式标签，当前如果你想解析例如xx.ts文件，则可以在数组里面新增：1234 &#123; test: /\.ts$/, use: 'ts-loader',&#125;, 下面来看看怎么加载图片资源，还是跟上述原一样，图片也是有类型的，我们首先得匹配文件后缀，然后去用loader去解析他们，这里我们需要用到 url-loader file-loader按照惯例先安装1&gt; cnpm i url-loader file-loader -D 12345678910111213141516171819module.exports = &#123; ... module: &#123; rules:[ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'], &#125;, &#123; test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', options: &#123; limit: 6000, name: 'img/[name].[hash:7].[ext]', &#125;, &#125; ] &#125;&#125;; 下一步就是往项目里增加图片了我们修改test.css文件test.css123body &#123; background: url(img.jpg);&#125; 浏览器就显示的全是刚刚设置的重复图片了 这里你又会问了，不对，你这里只用到了url-loader，file-loader不是多余的吗？ 不是的，你可以看看options，有一个limit参数，规定如果超过了6000bytes大小的文件会交给file-loader处理，因为如果图片小于这个数值，url-loader会把图片转成base64格式的图片加载，如果超过就自己不处理了，所以他们两者是有相依性的 使用npm脚本上面基本上都是使用一大段的命令行来执行项目，现在我们来简化一下修改package.json1234"scripts": &#123; "dev": "webpack-dev-server --open --config webpack.config.js", "build": "webpack --config webpack.config.js"&#125;, 命令行运行项目12&gt; npm run dev&gt; npm run build devServer在开发中你可能有很多需求，比如怎么通过ip访问项目，怎么把控制台信息输出的精简点，怎么修改端口等等？这个时候就需要用到devServer的配置了我们修改webpack.config.js,增加以下： 1234567891011module.exports = &#123; ... devServer: &#123; contentBase: './dist', // 告诉服务器从哪里提供内容 host: '0.0.0.0', // 指定使用一个 host。默认是 localhost useLocalIp: true, // 是否使用本地ip open: true, // 是否自动打开浏览器 port: 8080, // 端口号 noInfo: true, // 显示的 webpack 包(bundle)信息」的消息将被隐藏 &#125;,&#125; 是的，你现在可以不用在命令行里增加–open这个参数，在这里配置也是一样的 最后累了累了，写到这已经是凌晨了。不多BB了，现在基本的webpack操作应该都已经学会了吧，后面就是稍微深入的玩一玩webpack了，成为一个webpack配置工程师？ to be continued… 本文地址 webpack系列之初探]]></content>
      <categories>
        <category>javascript</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis简易教程以及使用nodejs连接redis]]></title>
    <url>%2F2019%2F04%2F19%2Fredis%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8nodejs%E8%BF%9E%E6%8E%A5redis%2F</url>
    <content type="text"><![CDATA[前言一直没机会学习redis，最近抽空学了一下，因为知道reids还是比较重要的，经常看到有人开发公众号因为没有对access_token进行缓存，判断是否过期，导致access_token的调用api次数超过限制而影响业务的情况，熟悉的人都知道使用redis基本上都是做缓存，因为他简单、速度快，可以说是个”快男”。使用reids做抽奖也很普遍，有空可以试试。本篇本章暂时只讲key、hash、list redis简介 Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 为什么要用redis（优势） 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 安装运行及调试（这里以mac为例） 先去官网下载安装包：http://www.redis.net.cn/download/ 解压安装 12345&gt; tar xzf redis-3.0.6.tar.gz&gt; make&gt; sudo make install&gt; cd /usr/local/bin &amp;&amp; redis-server // 开启redis服务&gt; cd /usr/local/bin &amp;&amp; redis-cli // 开启redis调试服务 开启调试会显示下面的界面，现在你就可以开始使用redis的api了12&gt; cd /usr/local/bin &amp;&amp; redis-cli127.0.0.1:6379&gt; 全局api查询键123456127.0.0.1:6379&gt; keys *1) &quot;wunci&quot;2) &quot;key&quot;3) &quot;me&quot;4) &quot;user&quot;5) &quot;user1&quot; 键的总数12127.0.0.1:6379&gt; dbsize (integer) 5 检查键是否存在存在返回 1 ，不存在返回 01234127.0.0.1:6379&gt; exists wunci (integer) 1127.0.0.1:6379&gt; exists wunci1 (integer) 0 删除键返回结果为成功删除键的个数12127.0.0.1:6379&gt; del user1 (integer) 1 键过期expire key seconds 当超过过期时间，会自动删除，key在seconds秒后过期expireat key timestamp 键在秒级时间戳timestamp后过期pexpire key milliseconds 当超过过期时间，会自动删除，key在milliseconds毫秒后过期pexpireat key milliseconds-timestamp key在毫秒级时间戳timestamp后过期 12127.0.0.1:6379&gt; expire user 10 // 10秒后user会被删除(integer) 1 randomkey 随机返回一个键1234127.0.0.1:6379&gt; randomkey &quot;wunci&quot;127.0.0.1:6379&gt; randomkey &quot;me&quot; redis 键（key）123456set key value [ex] [px] [nx|xx]ex为键值设置秒级过期时间px为键值设置毫秒级过期时间nx键必须不存在，才可以设置成功，用于添加xx与nx相反，键必须存在，才可以设置成功，用于更新setnx、setex 与上面的nx、ex作用相同 设置key(O(1))1234567127.0.0.1:6379&gt; set name 25 OK127.0.0.1:6379&gt; keys * 1) &quot;wunci&quot;2) &quot;key&quot;3) &quot;me&quot;4) &quot;name&quot; 获取key(O(1))12127.0.0.1:6379&gt; get name &quot;25&quot; 批量设置keymset key value [key value ……] 1234127.0.0.1:6379&gt; mset test1 1 test2 2OK127.0.0.1:6379&gt; get test2&quot;2&quot; 追加值(O(1))1234127.0.0.1:6379&gt; append test2 apend(integer) 6127.0.0.1:6379&gt; get test2 &quot;2apend&quot; 字符串长度12127.0.0.1:6379&gt; strlen test2(integer) 6 哈希（hash）HGET KEY_NAME FIELD_NAME类似javscript里的对象 {} 设置hash12127.0.0.1:6379&gt; HMSET hash name wunci age 25OK 获取hash12127.0.0.1:6379&gt; hmget hash name1) &quot;wunci&quot; 删除hashhdel key field [field ……] 会删除一个或多个field，返回结果为成功删除fiel的个数 1234127.0.0.1:6379&gt; hdel hash name(integer) 1127.0.0.1:6379&gt; hmget hash name // 再获取就返回nil1) (nil) 获取所有field12345678127.0.0.1:6379&gt; hkeys hash1) &quot;age&quot;127.0.0.1:6379&gt; HMSET hash name wunci from jiangxiOK127.0.0.1:6379&gt; hkeys hash1) &quot;age&quot;2) &quot;name&quot;3) &quot;from&quot; 获取所有value1234127.0.0.1:6379&gt; hvals hash1) &quot;25&quot;2) &quot;wunci&quot;3) &quot;jiangxi&quot; 列表（list） 操作类型 操作 添加 rpush 、lpush、linsert 查 lrange、lindex、llen 删除 lpop 、rpop、 lrem、ltrim 修改 lset 阻塞操作 blpop、brpop 添加（1）从左边插入元素lpush key value [value……]12127.0.0.1:6379&gt; LPUSH list redis(integer) 1 （1）从右边插入元素rpush key value [value……]12127.0.0.1:6379&gt; RPUSH list test(integer) 2 查找lrange key start end 索引下标从左到右分别是0到N-1，从右到左分别是-1到-N；end选项包含了自身lrange key 0 -1 可以从左到右获取列表的所有元素lrange mylist 1 3 获取列表中第2个到第4个元素 123127.0.0.1:6379&gt; lrange list 0 11) &quot;redis&quot;2) &quot;test&quot; 长度12127.0.0.1:6379&gt; llen key(integer) 2 删除我们先添加几个 12127.0.0.1:6379&gt; LPUSH list a b c(integer) 5 （1）从列表右侧弹出元素 rpop key （2）从列表左侧弹出元素 lpop key 先看看现在的列表123456127.0.0.1:6379&gt; lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot;5) &quot;test&quot; 删除12127.0.0.1:6379&gt; rpop list &quot;test&quot; 我们发现test被删除了，现在看看我们的列表12345127.0.0.1:6379&gt; lrange list 0 -11) &quot;c&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot; 修改lset key index newValue 修改指定索引下标的元素 1234567127.0.0.1:6379&gt; lset list 0 newValueOK127.0.0.1:6379&gt; lrange list 0 -11) &quot;newValue&quot;2) &quot;b&quot;3) &quot;a&quot;4) &quot;redis&quot; 第0个下标的元素被替换成最新的值 使用node连接redis1234&gt; npm init&gt; cnpm i reids -S&gt; touch index.js&gt; vim index.js 连接redisredis npm包链接 https://www.npmjs.com/package/redis 123456var redis = require('redis');var client = redis.createClient(6379, '127.0.0.1');client.on('error', function(err) &#123; console.log('Error ' + err);&#125;); 设置获取key123456client.set('user', JSON.stringify(&#123; name: 'wunci', age: '18' &#125;), redis.print);client.get('user', function(err, value) &#123; if (err) throw err; console.log('Got: ' + value); client.quit();&#125;); 控制台打印 123&gt; node index.jsReply: OKGot: &#123;&quot;name&quot;:&quot;wunci&quot;,&quot;age&quot;:&quot;18&quot;&#125; 设置获取hash1234client.hmset("hosts", "mjr", "1", "another", "23", "home", "1234");client.hgetall("hosts", function (err, obj) &#123; console.dir(obj);&#125;); 控制台打印12&gt; node index.js&#123; mjr: &apos;1&apos;, another: &apos;23&apos;, home: &apos;1234&apos; &#125; 设置获取list12client.LPUSH('list', [1, 2, 3, 4], redis.print);client.lrange('list', '0', '-1', redis.print); 控制台打印123&gt; node index.jsReply: 8Reply: 4,3,2,1,newValue,b,a,redis 基本用法和上面讲的都差不多，直接上去一顿写就完事了，完全可以不带脑子的使用各种api]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Node</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之实现一个简单的Vue]]></title>
    <url>%2F2018%2F09%2F11%2FJavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Vue%2F</url>
    <content type="text"><![CDATA[vue的使用相信大家都很熟练了，使用起来简单。但是大部分人不知道其内部的原理是怎么样的，今天我们就来一起实现一个简单的vue Object.defineProperty()实现之前我们得先看一下Object.defineProperty的实现，因为vue主要是通过数据劫持来实现的，通过get、set来完成数据的读取和更新。 1234567891011121314151617181920var obj = &#123;name:'wunci'&#125;var age = 24Object.defineProperty(obj,'age',&#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get () &#123; return age &#125;, set (newVal) &#123; console.log('我改变了',age +' -&gt; '+newVal); age = newVal &#125;&#125;)&gt; obj.age&gt; 24&gt; obj.age = 25;&gt; 我改变了 24 -&gt; 25&gt; 25 从上面可以看到通过get获取数据，通过set监听到数据变化执行相应操作，还是不明白的话可以去看看Object.defineProperty文档。 流程图 html代码结构1234567&lt;div id=&quot;wrap&quot;&gt; &lt;p v-html=&quot;test&quot;&gt;&lt;/p&gt; &lt;input type=&quot;text&quot; v-model=&quot;form&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;form&quot;&gt; &lt;button @click=&quot;changeValue&quot;&gt;改变值&lt;/button&gt; &#123;&#123;form&#125;&#125;&lt;/div&gt; js调用12345678910111213new Vue(&#123; el: '#wrap', data:&#123; form: '这是form的值', test: '&lt;strong&gt;我是粗体&lt;/strong&gt;', &#125;, methods:&#123; changeValue()&#123; console.log(this.form) this.form = '值被我改变了，气不气？' &#125; &#125;&#125;) Vue结构1234567891011class Vue&#123; constructor()&#123;&#125; proxyData()&#123;&#125; observer()&#123;&#125; compile()&#123;&#125; compileText()&#123;&#125;&#125;class Watcher&#123; constructor()&#123;&#125; update()&#123;&#125;&#125; Vue constructor 构造函数主要是数据的初始化 proxyData 数据代理 observer 劫持监听所有数据 compile 解析dom compileText 解析dom里处理纯双花括号的操作 Watcher 更新视图操作 Vue constructor 初始化1234567891011121314class Vue&#123; constructor(options = &#123;&#125;)&#123; this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach((key)=&gt; &#123; this.proxyData(key); &#125;); this.methods = options.methods // 事件方法 this.watcherTask = &#123;&#125;; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom &#125;&#125; 上面主要是初始化操作，针对传过来的数据进行处理 proxyData 代理data123456789101112131415161718class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; let that = this; Object.defineProperty(that, key, &#123; configurable: false, enumerable: true, get () &#123; return that.data[key]; &#125;, set (newVal) &#123; that.data[key] = newVal; &#125; &#125;); &#125; &#125; 上面主要是代理data到最上层，this.xxx的方式直接访问data observer 劫持监听123456789101112131415161718192021222324252627282930class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; let that = this Object.keys(data).forEach(key=&gt;&#123; let value = data[key] this.watcherTask[key] = [] Object.defineProperty(data,key,&#123; configurable: false, enumerable: true, get()&#123; return value &#125;, set(newValue)&#123; if(newValue !== value)&#123; value = newValue that.watcherTask[key].forEach(task =&gt; &#123; task.update() &#125;) &#125; &#125; &#125;) &#125;) &#125; &#125; 同样是使用Object.defineProperty来监听数据，初始化需要订阅的数据。把需要订阅的数据到push到watcherTask里，等到时候需要更新的时候就可以批量更新数据了。👇下面就是；遍历订阅池，批量更新视图。123456789set(newValue)&#123; if(newValue !== value)&#123; value = newValue // 批量更新视图 that.watcherTask[key].forEach(task =&gt; &#123; task.update() &#125;) &#125;&#125; compile 解析dom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Vue&#123; constructor(options = &#123;&#125;)&#123; ...... &#125; proxyData(key)&#123; ...... &#125; observer(data)&#123; ...... &#125; compile(el)&#123; var nodes = el.childNodes; for (let i = 0; i &lt; nodes.length; i++) &#123; const node = nodes[i]; if(node.nodeType === 3)&#123; var text = node.textContent.trim(); if (!text) continue; this.compileText(node,'textContent') &#125;else if(node.nodeType === 1)&#123; if(node.childNodes.length &gt; 0)&#123; this.compile(node) &#125; if(node.hasAttribute('v-model') &amp;&amp; (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA'))&#123; node.addEventListener('input',(()=&gt;&#123; let attrVal = node.getAttribute('v-model') this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'value')) node.removeAttribute('v-model') return () =&gt; &#123; this.data[attrVal] = node.value &#125; &#125;)()) &#125; if(node.hasAttribute('v-html'))&#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html') &#125; this.compileText(node,'innerHTML') if(node.hasAttribute('@click'))&#123; let attrVal = node.getAttribute('@click') node.removeAttribute('@click') node.addEventListener('click',e =&gt; &#123; this.methods[attrVal] &amp;&amp; this.methods[attrVal].bind(this)() &#125;) &#125; &#125; &#125; &#125;, compileText(node,type)&#123; let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g, txt = node.textContent; if(reg.test(txt))&#123; node.textContent = txt.replace(reg,(matched,value)=&gt;&#123; let tpl = this.watcherTask[value] || [] tpl.push(new Watcher(node,this,value,type)) if(value.split('.').length &gt; 1)&#123; let v = null value.split('.').forEach((val,i)=&gt;&#123; v = !v ? this[val] : v[val] &#125;) return v &#125;else&#123; return this[value] &#125; &#125;) &#125; &#125; &#125; 这里代码比较多，我们拆分看你就会觉得很简单了 首先我们先遍历el元素下面的所有子节点，node.nodeType === 3 的意思是当前元素是文本节点，node.nodeType === 1 的意思是当前元素是元素节点。因为可能有的是纯文本的形式，如纯双花括号就是纯文本的文本节点，然后通过判断元素节点是否还存在子节点，如果有的话就递归调用compile方法。下面重头戏来了，我们拆开看：12345if(node.hasAttribute('v-html'))&#123; let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html')&#125; 上面这个首先判断node节点上是否有v-html这种指令，如果存在的话，我们就发布订阅，怎么发布订阅呢？只需要把当前需要订阅的数据push到watcherTask里面，然后到时候在设置值的时候就可以批量更新了，实现双向数据绑定，也就是下面的操作123that.watcherTask[key].forEach(task =&gt; &#123; task.update()&#125;) 然后push的值是一个Watcher的实例，首先他new的时候会先执行一次，执行的操作就是去把纯双花括号 -&gt; 1，也就是说把我们写好的模板数据更新到模板视图上。最后把当前元素属性剔除出去，我们用Vue的时候也是看不到这种指令的，不剔除也不影响 至于Watcher是什么，看下面就知道了 Watcher123456789101112class Watcher&#123; constructor(el,vm,value,type)&#123; this.el = el; this.vm = vm; this.value = value; this.type = type; this.update() &#125; update()&#123; this.el[this.type] = this.vm.data[this.value] &#125;&#125; 之前发布订阅之后走了这里面的操作，意思就是把当前元素如：node.innerHTML = ‘这是data里面的值’、node.value = ‘这个是表单的数据’ 那么我们为什么不直接去更新呢，还需要update做什么，不是多此一举吗？其实update记得吗？我们在订阅池里面需要批量更新，就是通过调用Watcher原型上的update方法。 效果在线效果地址，大家可以浏览器看一下效果，由于本人太懒了，gif效果图就先不放了，哈哈😄😄 完整代码完整代码已经放到github上了 -&gt; MyVue 参考剖析Vue原理&amp;实现双向绑定MVVM仿Vue实现极简双向绑定 QQ群有兴趣的同学可以加qq群: 725165362 点击加入]]></content>
      <categories>
        <category>javascript</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之Web Worker]]></title>
    <url>%2F2018%2F09%2F10%2FJavaScript%E4%B9%8BWeb-Worker%2F</url>
    <content type="text"><![CDATA[介绍 Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。此外，他们可以使用XMLHttpRequest执行 I/O (尽管responseXML和channel属性总是为空)。一旦创建， 一个worker 可以将消息发送到创建它的JavaScript代码, 通过将消息发布到该代码指定的事件处理程序（反之亦然）。 Web Worker使用要点 同源限制：分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。 DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象。但是，Worker 线程可以navigator对象和location对象。 通信联系：Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。 脚本限制：Worker 线程不能执行alert()方法和confirm()方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。 文件限制：Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。后面我们允许会做处理。 安装http-serverWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。所以我们得起一个项目。使用http-server最简单安装：1&gt; cnpm i -g http-server 使用：1&gt; http-server 基本使用我们新建一个文件夹名叫worker，里面新建三个文件分别是123index.htmlmain.jsworker.js 新建一个worker线程很简单，只需： 1var worker = new Worker(&apos;worker.js&apos;) main.js:12345678910var worker = new Worker('./worker.js')console.log('worker running')worker.addEventListener('message',e =&gt; &#123; console.log('main: ', e.data);&#125;)// 也可使用：// worker.onmessage = (e)=&gt;&#123;// console.log('main: ', e.data);// &#125;worker.postMessage('hello worker,I am from main.js') worker.js:123456console.log('worker task running')onmessage = (e)=&gt;&#123; console.log('worker task receive', e.data); // 发送数据事件 postMessage('Hello, I am from Worker.js');&#125; 在worker文件夹下，命令行输入http-server,启动项目，用浏览器打开，看控制台：1234worker runningworker task runningworker task receive hello worker,I am from main.jsmain: Hello, I am from Worker.js 从上面可以看到，worker通过onmessage来监听数据，通过postMessgae来发送数据 终止 worker1worker.terminate(); 处理错误123worker.addEventListener(&apos;error&apos;, (e) =&gt; &#123; console.log(&apos;main error&apos;, &apos;filename:&apos; + e.filename + &apos;message:&apos; + e.message + &apos;lineno:&apos; + e.lineno;&#125;); event.filename: 导致错误的 Worker 脚本的名称； event.message: 错误的信息； event.lineno: 出现错误的行号； 加载外部脚本main.js1var worker = new Worker('./worker1.js'); worker1.js12345console.log("I'm worker1")importScripts('worker2.js', 'worker3.js');// 或者// importScripts('worker2.js');// importScripts('worker3.js'); worker2.js1console.log("I'm worker2") worker3.js1console.log("I'm worker3") 兼容性https://caniuse.com/#feat=webworkers兼容性还不是很乐观，不过在移动端的兼容性还不错 参考使用 Web WorkersWeb Worker 使用教程]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之实现一个简单的promise]]></title>
    <url>%2F2018%2F09%2F09%2FJavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[我们在开发过程中大多会用到promise，想必大家对promise的使用都很熟练了，今天我们就来实现一个简单的promise，实现的效果如有出入还往指正。 整体结构我们先来梳理一下整体的结果，以便后续好操作 1234567891011121314151617class MyPromise &#123; constructor(fn)&#123; &#125; resolve()&#123; &#125; then()&#123; &#125; reject()&#123; &#125; catch()&#123; &#125;&#125; Promise理论知识 摘抄至 http://es6.ruanyifeng.com/#docs/promise#Promise-all Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 总结一下就是promise有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败），还有就是状态的改变只能是pending -&gt; fulfilled 或者 pending -&gt; rejected，这些很重要 实现构造函数现在我们开始实现构造函数 1234567891011class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; ...&#125; 构造函数接收一个参数fn，且这个参数必须是一个函数，因为我们一般这样使用new Promise((resolve,reject)=&gt;{});然后初始化一下promise的状态，默认开始为pending，初始化value的值。fn接收两个参数，resolve、reject resolve12345678910111213141516class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; ...&#125; 当resolve执行，接收到一个值之后；状态就由 pending -&gt; fulfilled；当前的值为接收的值 reject1234567891011121314151617181920class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125;&#125; 当reject执行，接收到一个值之后；状态就由 pending -&gt; rejected；当前的值为接收的值 then1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125; then(fulfilled,rejected)&#123; if (typeof fulfilled !== 'function' &amp;&amp; typeof rejected !== 'function' ) &#123; return this; &#125; if (typeof fulfilled !== 'function' &amp;&amp; this.state === 'fulfilled' || typeof rejected !== 'function' &amp;&amp; this.state === 'rejected') &#123; return this; &#125; return new MyPromise((resolve,reject)=&gt;&#123; if(fulfilled &amp;&amp; typeof fulfilled === 'function' &amp;&amp; this.state === 'fulfilled')&#123; let result = fulfilled(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; if(rejected &amp;&amp; typeof rejected === 'function' &amp;&amp; this.state === 'rejected')&#123; let result = rejected(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; &#125;) &#125;&#125; then的实现比较关键，首先有两个判断，第一个判断传的两个参数是否都是函数，如果部不是return this执行下一步操作。第二个判断的作用是，比如，现在状态从pending -&gt; rejected;但是中间代码中有许多个.then的操作，我们需要跳过这些操作执行.catch的代码。如下面的代码，执行结果只会打印1123456789new Promise((resolve,reject)=&gt;&#123; reject(1)&#125;).then(()=&gt;&#123; console.log(2)&#125;).then(()=&gt;&#123; console.log(3)&#125;).catch((e)=&gt;&#123; console.log(e)&#125;) 我们继续，接下来看到的是返回了一个新的promise，真正then的实现的确都是返回一个promise实例。这里不多说 下面有两个判断，作用是判断是rejected还是fulfilled,首先看fulfilled，如果是fulfilled的话，首先执行fulfilled函数，并把当前的value值传过去，也就是下面这步操作,res就是传过去的value值，并执行了(res)=&gt;{console.log(res)}这段代码;执行完成之后我们得到了result；也就是2这个结果，下面就是判断当前结果是否是一个promise实例了，也就是下面注释了的情况，现在我们直接执行resolve(result);1234567new Promise((resolve,reject)=&gt;&#123; resolve(1)&#125;).then((res)=&gt;&#123; console.log(res) return 2 //return new Promise(resolve=&gt;&#123;&#125;)&#125;) 剩下的就不多说了，可以debugger看看执行结果 catch123456class MyPromise &#123; ... catch(rejected)&#123; return this.then(null,rejected) &#125;&#125; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MyPromise &#123; constructor(fn)&#123; if(typeof fn !== 'function') &#123; throw new TypeError(`MyPromise fn $&#123;fn&#125; is not a function`) &#125; this.state = 'pending'; this.value = void 0; fn(this.resolve.bind(this),this.reject.bind(this)) &#125; resolve(value)&#123; if(this.state !== 'pending') return; this.state = 'fulfilled'; this.value = value &#125; reject(reason)&#123; if(this.state !== 'pending') return; this.state = 'rejected'; this.value = reason &#125; then(fulfilled,rejected)&#123; if (typeof fulfilled !== 'function' &amp;&amp; typeof rejected !== 'function' ) &#123; return this; &#125; if (typeof fulfilled !== 'function' &amp;&amp; this.state === 'fulfilled' || typeof rejected !== 'function' &amp;&amp; this.state === 'rejected') &#123; return this; &#125; return new MyPromise((resolve,reject)=&gt;&#123; if(fulfilled &amp;&amp; typeof fulfilled === 'function' &amp;&amp; this.state === 'fulfilled')&#123; let result = fulfilled(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; if(rejected &amp;&amp; typeof rejected === 'function' &amp;&amp; this.state === 'rejected')&#123; let result = rejected(this.value); if(result &amp;&amp; typeof result.then === 'function')&#123; return result.then(resolve,reject) &#125;else&#123; resolve(result) &#125; &#125; &#125;) &#125; catch(rejected)&#123; return this.then(null,rejected) &#125;&#125; 测试123456789101112131415161718192021222324new MyPromise((resolve,reject)=&gt;&#123; console.log(1); //reject(2) resolve(2) console.log(3) setTimeout(()=&gt;&#123;console.log(4)&#125;,0)&#125;).then(res=&gt;&#123; console.log(res) return new MyPromise((resolve,reject)=&gt;&#123; resolve(5) &#125;).then(res=&gt;&#123; return res &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log('e',e)&#125;)执行结果：&gt; 1&gt; 3&gt; 2&gt; 5&gt; 4 原生promise123456789101112131415161718192021222324new Promise((resolve,reject)=&gt;&#123; console.log(1); //reject(2) resolve(2) console.log(3) setTimeout(()=&gt;&#123;console.log(4)&#125;,0)&#125;).then(res=&gt;&#123; console.log(res) return new Promise((resolve,reject)=&gt;&#123; resolve(5) &#125;).then(res=&gt;&#123; return res &#125;)&#125;).then(res=&gt;&#123; console.log(res)&#125;).catch(e=&gt;&#123; console.log('e',e)&#125;)执行结果：&gt; 1&gt; 3&gt; 2&gt; 5&gt; 4]]></content>
      <categories>
        <category>javascript</category>
        <category>promise</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavsScript之浅拷贝与深拷贝]]></title>
    <url>%2F2018%2F07%2F29%2FJavsScript%E4%B9%8B%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在开发的过程中，我们往往需要复制一个数据，在复制基本数据类型的时候不会出现问题，如string、number、null等。但是我们复制一个引用类型的数据时，往往会出现问题，如array、object。 浅拷贝看下面这段代码123var arr1 = [1,2,3];var arr2 = arr1;arr2.push(4) 我们打印一下看看arr1 arr2的结果12arr1: [1, 2, 3, 4]arr2: [1, 2, 3, 4] 我们发现，改变arr2的同时也改变了arr1，WTF？ 接下来我们看看对象12345var obj1 = &#123; name:'wunci' &#125;;var obj2 = obj1obj2.age = 24 我们打印一下看看arr1`arr2`的结果12obj1: &#123;name: "wunci", age: 24&#125;obj2: &#123;name: "wunci", age: 24&#125; 和预想的一样，都被影响了。why?因为引用类型的复制，两个引用类型的指针都指向同一个堆内存 网上偶尔会看到有人说slice、concat是深拷贝，其实这两个是浅复制，如下123var arr1 = [1,2,3];var arr2 = arr1.slice();arr2.push(4) 结果：12arr1 [1, 2, 3]arr2 [1, 2, 3, 4] 数组元素只是基本数据类型不会有影响，那么我们看下面的123var arr1 = [1,2,3,[4]];var arr2 = arr1.slice();arr2[3].push(5) 结果12arr1: [1,2,3,[4,5]] &lt;----- 被影响了arr2: [1,2,3,[4,5]] 即使使用了slice, 两个数组也相互影响了，类似方法除了slice、concat还有Array.from、... 深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的拷贝实体，而不是引用 深拷贝Object.assignObject.assign可以进行一层的深度拷贝，也就是跟slice类型的效果1234567891011121314151617181920212223242526var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.age = 24结果：obj1: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;obj2: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125;, age: 24 &#125;; 但是我们看下面的例子12345678910111213141516171819202122232425262728var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = Object.assign(&#123;&#125;, obj1)obj2.age = 24obj2.test4.val = '1';结果： obj1: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: 1&#125; &lt;----- 被影响了 &#125;;obj2: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: 1&#125;, age: 24 &#125;; JSON.parse(JSON.stringify(obj))说到深拷贝，你一定会想到JSON.parse(JSON.stringify(obj));没错，这样可以完成一个深拷贝，看下面的例子： 12345var obj1 = &#123; name: 'wunci' &#125;;var obj2 = JSON.parse(JSON.stringify(obj1))obj2.age = 24 结果12obj1: &#123;name: "wunci"&#125; &lt;----- 没有被影响了obj2: &#123;name: "wunci", age: 24&#125; perfect，但是这个方法会有一个问题，如下例：123456789var var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = JSON.parse(JSON.stringify(obj1))obj2.age = 24 结果12345678910111213obj1: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;obj2: &#123; name: "wunci", age: 24, test1: null, test4: &#123;&#125; &#125; WTF，那两个个跑哪去了？所以这个方法不能够拷贝值为undefined、function 深拷贝实现那么怎么进行深拷贝呢？我的方法是：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function deepCopy(obj)&#123; var result; var toString = Object.prototype.toString if(toString.call(obj) === '[object Array]')&#123; result = [] for(var i = 0 ;i &lt; obj.length; i++)&#123; result[i] = deepCopy(obj[i]) &#125; &#125;else if(toString.call(obj) === '[object Object]')&#123; result = &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; result[key] = deepCopy(obj[key]) &#125; &#125; &#125;else&#123; return obj &#125; return result&#125;测试一下：var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = deepCopy(obj1)obj2.age = 24obj2.test4.val = '1';返回： obj1: &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &lt;----- 没有被影响了 &#125;;obj2: &#123; age: 24, name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;val: '1'&#125; &#125;; jQuery的实现123456789var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = $.extend(true, &#123;&#125;, obj1)obj2.age = 24 lodash的实现123456789var obj1 = &#123; name: 'wunci', test1: null, test2: undefined, test3: function()&#123;alert(1)&#125;, test4: &#123;&#125; &#125;;var obj2 = _.cloneDeep(obj1)obj2.age = 24 GitHub：wunci 个人小程序]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node项目服务器部署(新手教程)]]></title>
    <url>%2F2018%2F07%2F28%2Fnode%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-%E6%96%B0%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[写在前面之前在github写了几个项目，然后一直有很多人问我node项目怎么部署到服务器上，于是乎应大家要求就写了这篇文章，此篇教程只提供给新手借鉴，如果你是大佬的话可以不用往下看了，教程多少有些缺陷，都是按照自己的印象写出来的，所以有问题还望指正。 linux服务器安装node首先下载node包1wget https://npm.taobao.org/mirrors/node/latest-v8.x/node-v8.1.0-linux-x64.tar.gz 解压1tar xvf node-v8.1.0-linux-x64.tar.gz 12ln -s ~/node-v8.1.0-linux-x64/bin/node /usr/local/bin/nodeln -s ~/node-v8.1.0-linux-x64/bin/npm /usr/local/bin/npm 最后node -v查看node版本，如果出现以下就表示安装成功了1v8.1.0 如果你需要升级node版本，执行以下命令即可12sudo npm i -g nn stable 安装pm2pm2是一个进程守护工具,类似的还有forever 1sudo npm i pm2 -g 然后执行，如果不映射的话，会出现pm2不是内部指令的错误1ln -s ~/node-v8.1.0-linux-x64/bin/pm2 /usr/local/bin/pm2 我们顺便把git和cnpm也安装了123yum install gitsudo npm i -g cnpmln -s ~/node-v8.1.0-linux-x64/bin/cnpm /usr/bin/cnpm 安装mysql卸载已有的mysql12rpm -qa|grep -i mysqlyum remove &apos;mysql&apos; 下载mysql的repo源12wget http://repo.mysql.com//mysql57-community-release-el7-7.noarch.rpmrpm -ivh mysql57-community-release-el7-7.noarch.rpm 安装123yum install mysql-serveryum install mysql-develyum install mysql 然后查看刚刚安装的mysql1rpm -qa|grep -i mysql 登录1234service mysqld status 查看mysql当前的状态service mysqld stop 停止mysqlservice mysqld restart 重启mysqlservice mysqld start 启动mysql 在完成上述步骤之后登陆时可能遇到ERROR 2002 (HY000): Can‘t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock‘ (2)错误。 这个错误的原因是/var/lib/mysql的访问权限问题。下面的命令把/var/lib/mysql的拥有者改为当前用户。 12chown -R openscanner:openscanner /var/lib/mysqlchown -R root:root /var/lib/mysql 于是乎接下来就是查看一下/var/lib/mysql/mysql.sock文件是否存在，第一次查看时该文件不存在，后来在/etc/my.cnf文件中添加了user=mysql然后尝试登录1mysql -u root 会出现ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password: NO) 登录root帐号需要密码，现在我们没有设置密码，哪来的密码。于是乎我们开始忘记密码的操作第一步，在/etc/my.cnf文件中添加skip-grant-tables第二步，重启mysql，service mysqld restart第三步，登录mysql，mysql -u root第四步，修改密码：1234mysql&gt;use mysql;mysql&gt;update mysql.user set authentication_string=password(&apos;你的密码&apos;) where user=&apos;root&apos;;mysql&gt;flush privileges;mysql&gt;exit; 第五步，恢复/etc/my.cnf，将skip-grant-tables删除或者注释掉第六步，重启mysql，service mysqld restart 分配用户 host指定该用户在哪个主机上可以登陆，此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录，如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录;也可以指定某台机器可以远程登录; 12CREATE USER &apos;username&apos;@&apos;host&apos; IDENTIFIED BY &apos;password&apos;;CREATE USER &apos;test&apos;@&apos;%&apos; IDENTIFIED BY &apos;密码&apos;; 给创建的用户权限 privileges：用户的操作权限,如SELECT，INSERT，UPDATE等.如果要授予所的权限则使用ALL;databasename：数据库名。tablename：表名,如果要授予该用户对所有数据库和表的相应操作权限则可用表示, 如.*. 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; 下面表示给test用户所有数据库和表的权限 mysql&gt;GRANT ALL ON . TO ‘test‘@’%’; 安装nginx安装1yum -y install nginx 启动1service nginx start 查找nginx安装在哪，我这里是/etc/nginx/conf.d1whereis nginx 进入文件夹1cd /etc/nginx/conf.d 然后新建文件，这里以我的域名为例1vi wunci.github.io.conf 然后里面的文件内容我们先不写，我们先把node项目部署一下 使用pm2启动node项目这里以我的项目为例koa2-blog我们先找到合适的文件夹存放我们得项目，然后git clone一下（git我们之前安装过了） 该项目的数据库名叫nodeSql，使用运行之前得先建立好数据库，然后再运行项目，登录数据库执行 create database nodesql; 1234git clone https://github.com/wunci/Koa2-blog.gitcd Koa2-blogcnpm i pm2 start index.js 上面pm2我们也安装过，该项目监听的是3000端口，项目已经运行起来了可以使用pm2 list查看进程列表，使用pm2 log打印日志 nginx配置记得刚刚我们没有编写wunci.github.io.conf文件现在开始写入以下内容，blog.wunci.site是我的域名，你可以在你的服务器平台去解析一下，目前我们监听的是3000端口，所以代理到30001234567server &#123; listen 80; server_name blog.wunci.site; location / &#123; proxy_pass http://127.0.0.1:3000; &#125;&#125; 检验nginx是否正确配置1nginx -t 重启nginx1service nginx restart 如果不成功，可能还需执行一下命令12systemctl stop httpdsystemctl disable httpd 完结OK，现在访问域名看看是否有效果了，整个流程可能有写纰漏，大致流程也差不多了，希望对你有帮助 GitHub：wunci 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之函数记忆]]></title>
    <url>%2F2018%2F07%2F12%2FJavaScript%E4%B9%8B%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[最近在读语言精粹，读到函数记忆这块，觉得有必要记录一下 我们在开发过程中经常使用递归的方式调用函数，但是开发过程中很少有关心性能问题 我们看一下下面这段代码123456789var count = 0var f = function(n)&#123; count++ return n &lt; 2 ? n : f(n - 1) + f(n - 2);&#125;for(var i = 0; i &lt;= 10; i++)&#123; console.log(i,f(i))&#125;console.log('执行次数', count) 结果1234567891011120 01 12 13 24 35 56 87 138 219 3410 55'执行次数', 453 执行一遍发现，f这个函数被调用了453次，我们调用了11次，而它自身调用了442次去计算可能已经被刚计算过的值。如果我们让函数具备记忆功能，就可以显著减少运算量。 接下来，我们定义一个memo的数组来保存我们得储存结果，并把它隐藏在闭包中，让该函数能一直访问到这个数组，不被垃圾回收机制回收 123456789101112131415161718var count = 0var f = function()&#123; var memo = [0,1]; var fib = function(n)&#123; count++ var result = memo[n]; if(typeof result !== 'number')&#123; result = fib(n - 1) + fib(n - 2) memo[n] = result &#125; return result &#125; return fib&#125;()for(var i = 0; i &lt;= 10; i++)&#123; console.log(i,f(i))&#125;console.log('执行次数', count) 执行结果1234567891011120 01 12 13 24 35 56 87 138 219 3410 55执行次数 29 现在f函数只被调用了29次，我们调用了它11次，它调用了18次去取得之前储存的结果。 先就分享到这吧，关键拓宽思路 GitHub：wunci]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之原型与原型链]]></title>
    <url>%2F2018%2F06%2F13%2FJavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[万物皆对象在JavaScript中除值类型之外，其他的都是对象，为了说明这点，我们举几个例子我们可以使用typeof来做类型判断 123456789typeof a; // undefinedtypeof 1; // numbertypeof 'wunci'; // stringtypeof true; // booleantypeof function()&#123;&#125;; // functiontypeof []; // objecttypeof null; // objecttypeof &#123;&#125;; // object 除了undefined、number、string、boolean属于值类型之外，其他都是对象。你可能要问了，不是还有一个是function吗？要校验他是不是应该对象可以这样做:12var fn = function()&#123;&#125;fn instanceof Object // true 由上面的例子所示，函数确实是对象，为什么呢？我们看一下下面的例子12345function Person(name)&#123; this.name = name; &#125;var person = new Person('wunci');console.log(person) // Person &#123;name: "wunci"&#125; 由此我们可以得知，对象都是通过函数创建的，这么说你可能又会说不对，你看下面的就不是函数创建的1var person = &#123;name:'wunci'&#125; 你咋就这么飘呢？我竟无言以对，没错，这是个意外、意外、意外。但是归根结底他还是通过函数创建的12var person = new Object()person.name = 'wunci' so，现在你只要知道对象是通过函数创建的就可以了，来跟着我读：第一遍 对象都是通过函数创建的第二遍 对象都是通过函数创建的第三遍 对象都是通过函数创建的 构造函数(constructor)12345function Person(name)&#123; this.name = name&#125;var person1 = new Person('wunci 1')var person2 = new Person('wunci 2') 上面Person就是一个构造函数，我们通过new的方式创建了一个实例对象person我们来看看person1和person2的constructor(构造函数)是不是指向Person的12person1.constructor === Person // trueperson2.constructor === Person // true 原型(prototype)在JavaScript中，每定义一个函数都会产生一个prototype(原型)属性，这个属性指向函数的原型对象12345678function Person()&#123;&#125;Person.prototype.name = 'wunci'Person.prototype.age = '24'Person.prototype.sayAge = function()&#123; console.log(this.age)&#125;var person = new Person()person.sayAge(); // 24 那么这个prototype到底是什么呢？跟构造函数有关系吗？ 上图就可以反映出他们之间的关系 其实函数的prototype指向函数的原型对象，每个对象都会关联另外一个对象，也就是原型，上面的例子改成：1234567Person.prototype = &#123; name: 'wunci', age: 24, satAge: function()&#123; console.log(this.age) &#125;&#125; 隐式原型(__proto__)上面我们说到每定义一个函数都会产生一个原型，每个函数它不止有原型，还有一个__proto__(隐式原型)每个对象都有一个__proto__属性，指向创建该对象函数的prototype，我们可以来试试，还是上面的例子：123function Person()&#123;&#125;var person = new Person()person.__proto__ === Person.prototype // true 现在他们的关系图如下 由上图我们可以知道：123Person.prototype.constructor = Personperson.__proto__ = Person.prototypeperson.constructor = Person 我们可以看到person.__proto__指向构造函数的原型，那么构造函数的原型即Person的__proto__指向哪里呢？我们知道构造函数其实就是由Function来创建的，由此得出:1Person.__proto__ === Function.prototype 那么构造函数的原型即Person.prototype的__proto__指向哪里呢？原型对象其实是通过Object生成的，自然而然的得出:1Person.prototype.__proto__ === Object.prototype 那么Object.prototype的__proto__指向哪里呢？答案是null，最终得到下面的图 抛开这张图，来看看下面几道题 person.__proto__ Person.__proto__ Person.prototype.__proto__ Object.__proto__ Object.prototype.__proto__ 解： 每个对象都有一个__proto__属性，指向创建该对象函数的prototype，因为Person是person的构造函数Person === person.constructor为true,所以：person.__proto__ === Person.prototype Person构造函数是由Function创建的，所以可以得出Person.__proto__ === Fucntion.prototype 我们上面说过Person.prototype其实是一个对象，而对象是由Object创建的，所以 Person.prototype.__proto__ === Object.prototype Object对象都是函数创建的，所以Object.__proto__ === Function.prototype 虽然Object.prototype是一个对象但是他的__proto__为null 实例和原型当我们要取一个值的时候，会先从实例中取，如果实例中存在，则取实例的值，如果实例不存在，则会顺着原型里找，直到找到 12345678function Person()&#123;&#125;Person.prototype.name = '我来自原型'var person = new Person()person.name = '我来自实例'console.log(person.name); // 我来自实例delete person.nameconsole.log(person.name)); // 我来自原型 首先person实例中有这个属性，返回我来自实例,然后将它删除之后，会从原型中招，也就是person.__proto__，因为Person.prototype === person.__proto__，所以得到我来自原型 总结原型和原型链基本已经讲解完，不过还有待完善，如有错误，还望指正 GitHub：wunci 个人小程序 QQ群有兴趣的同学可以加qq群: 725165362 点击加入]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript之节流与防抖]]></title>
    <url>%2F2018%2F06%2F12%2FJavaScript%E4%B9%8B%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%2F</url>
    <content type="text"><![CDATA[背景我们在开发的过程中会经常使用如scroll、resize、touchmove等事件，如果正常绑定事件处理函数的话，有可能在很短的时间内多次连续触发事件，十分影响性能。因此针对这类事件要进行节流或者防抖处理 节流节流的意思是，在规定的时间内只会触发一次函数，如我们设置函数500ms触发一次，之后你无论你触发了多少次函数，在这个时间内也只会有一次执行效果 先来看一个例子 See the Pen gKWLpO by wunci (@wunci) on CodePen. 我们看到使用了节流的在1000ms内只触发了一次，而没有使用节流的则频繁触发了调用的函数 接下来看看代码实现v1 第一次不触发，不传参实现12345678910111213function throttle(fn,interval)&#123; var timer; return function()&#123; if(timer)&#123; return &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn() &#125;, interval || 1000); &#125; &#125; 效果是实现了，但是我在尝试在执行函数里console.log(this)，结果发现this指向的是window，而且还发现我们不能传递参数，下面就来改进一下v2 第一次触发函数，接收参数1234567891011121314151617181920function throttle(fn,interval)&#123; var timer, isFirst = true; return function()&#123; var args = arguments, that = this; if(isFirst)&#123; fn.apply(that,args) return isFirst = false &#125; if(timer)&#123; return &#125; timer = setTimeout(() =&gt; &#123; clearTimeout(timer) timer = null fn.apply(that,args) &#125;, interval || 1000); &#125; &#125; 防抖防抖的意思是无论你触发多少次函数，只会触发最后一次函数。最常用的就是在表单提交的时候，用户可能会一段时间内点击很多次，这个时候可以增加防抖处理，我们只需要最后一次触发的事件 先来看一个例子 See the Pen pKPeyv by wunci (@wunci) on CodePen. 我们看到使用了防抖的方框，无论你在里面触发了多少次函数，都只会触发最后的那一次函数，而没有使用防抖的则频繁触发了调用的函数 v1 第一次不触发函数 1234567891011121314function debounce(fn,interval)&#123; var timer; return function()&#123; var args = arguments, that = this; if(timer)&#123; clearTimeout(timer) timer = null &#125; timer = setTimeout(() =&gt; &#123; fn.apply(null,args) &#125;, interval || 1000); &#125;&#125; 上面这段代码仍然可以正常执行，但是我们并没有指定他的this v2 第一次就触发函数123456789101112131415161718192021222324function debounce(fn,interval)&#123; var timer, isFirst = true, can = false; return function()&#123; var args = arguments, that = this; if(timer)&#123; clearTimeout(timer) timer = null &#125; if(isFirst)&#123; fn.apply(that,args) isFirst = false setTimeout(() =&gt; &#123; can = true &#125;, interval || 1000); &#125;else if(can)&#123; timer = setTimeout(() =&gt; &#123; fn.apply(null,args) &#125;, interval || 1000); &#125; &#125;&#125; 如有雷同，纯属抄我（开玩笑） 如有错误，还望指正，仅供参考 GitHub：wunci QQ群有兴趣的同学可以加qq群: 725165362 点击加入 个人小程序]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP缓存——304与200 from cache]]></title>
    <url>%2F2018%2F03%2F06%2FHTTP%E7%BC%93%E5%AD%98%E2%80%94%E2%80%94304%E4%B8%8E200-from-cache%2F</url>
    <content type="text"><![CDATA[HTTP与缓存相关的字段1. 通用字段 字段名称 释义 Cache-Control 控制缓存具体的行为 Pragma HTTP1.0时的遗留字段，当值为”no-cache”时强制验证缓存 Date 创建报文的日期时间(启发式缓存阶段所用) 2. response字段 字段名称 释义 ETag 服务器生成资源的唯一标识 Vary 代理服务器缓存的管理信息 Age 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小) 3. request字段 字段名称 释义 If-Match 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改 If-None-Match 和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改 If-Modified-Since 比较资源前后两次访问最后的修改时间是否一致 If-Unmodified-Since 比较资源前后两次访问最后的修改时间是否一致 4. 实体字段 字段名称 释义 Expires 告知客户端资源缓存失效的绝对时间 Last-Modified 资源最后一次修改的时间 协商缓存（304） If-modified-Since/Last-Modified 浏览器在发送请求的时候服务器会检查请求头request header里面的If-modified-Since，如果最后修改时间相同则返回304，否则给返回头(response header)添加last-Modified并且返回数据(response body)。12if-modified-since:Wed, 31 May 2017 03:21:09 GMTif-none-match:&quot;42DD5684635105372FE7720E3B39B96A&quot; If-None-Match/Etag 浏览器在发送请求的时候服务器会检查请求头(request header)里面的if-none-match的值与当前文件的内容通过hash算法（例如 nodejs: cryto.createHash(&#39;sha1&#39;)）生成的内容摘要字符对比，相同则直接返回304，否则给返回头(response header)添加etag属性为当前的内容摘要字符，并且返回内容。12etag:&quot;42DD5684635105372FE7720E3B39B96A&quot;last-modified:Wed, 31 May 2017 03:21:09 GMT 请求头last-modified的日期与响应头的last-modified一致请求头if-none-match的hash与响应头的etag一致所用会返回Status Code: 304 强缓存（200 from cache） 如果设置了Expires(XX时间过期)或者Cache-Control（http1.0不支持）(经历XX时间后过期)且没有过期，命中cache的情况下，from cache不去发出请求。如果强刷（如ctrl+r）会发起请求，但是如果没有修改会返回304内容未修改，如果已经改变则返回新内容。max-age &gt; Expires。 expires/cache-control虽然是强缓存，但用户主动触发的刷新行为，还是会采用缓存协商的策略，主动触发的刷新行为包括点击刷新按钮、右键刷新、f5刷新、ctrl+f5刷新等。 当然如果在控制台里面选中了disable cahce则无论如何都会请求最新内容(304协商缓存、强缓存都无效)，因为1.不会检查本地是否有缓存。2.请求头信息(request header)既没有If-Modified-Since也没有If-None-Match来让服务端判断。地址栏输入的地址按下回车键，该地址页面请求（仅仅是该url）的request header都会带上cache-contro:max-age=0，所以不会命中强缓存，但是通过链接点击的地址会命中缓存 chrome下查看所有的from cache文件：chrome://view-http-cache/ 区别 触发 200 from cache： 直接点击链接访问 输入网址按回车访问 二维码扫描 触发 304： 刷新页面时触发 设置了长缓存、但Entity Tags没有移除时触发 流程图 GitHub：wunci 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>HTTP</tag>
        <tag>缓存</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs微信支付之扫码支付]]></title>
    <url>%2F2018%2F02%2F14%2Fnodejs%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E4%B9%8B%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[前言本篇文章主要是记录本人在微信扫码支付过程中所遇到的问题，给大家一个借鉴作用，希望对你们有帮助 开发环境 nodejs v8.1.0 egg v1.1.0 准备工作 微信公众号-appid 微信商户号-mch_id key值(签名算法所需,其实就是一个32位的密码，可以用md5生成一个)(key设置路径：微信商户平台(pay.weixin.qq.com)–&gt;账户设置–&gt;API安全–&gt;密钥设置) 扫码支付-统一下单以下才用的是微信模式二，因为比较简单123456789101112131415 let MD5 = require('md5'), xml2js = require('xml2js'), url = "https://api.mch.weixin.qq.com/pay/unifiedorder",// 下单请求地址 appid = '公众号id', mch_id = '微信商户号'； notify_url = '回调地址', out_trade_no = '自己设置的订单号',// 微信会有自己订单号、我们自己的系统需要设置自己的订单号 total_fee = '订单金额',// 注意，单位为分 body = '商品简单描述', trade_type = 'NATIVE',// 交易类型，JSAPI--公众号支付、NATIVE--原生扫码支付、APP--app支付 nonce_str = moment().format('YYYYMMDDHHmmssSSS'),// 随机字符串32位以下 stringA = `appid=$&#123;公众号id&#125;&amp;body=$&#123;body&#125;&amp;mch_id=$&#123;微信商户号&#125;&amp;nonce_str=$&#123;nonce_str&#125;&amp;notify_url=$&#123;notify_url&#125;&amp;out_trade_no=$&#123;out_trade_no&#125;&amp;spbill_create_ip=$&#123;ctx.request.ip&#125;&amp;total_fee=$&#123;total_fee&#125;&amp;trade_type=$&#123;trade_type&#125;`, stringSignTemp = stringA + "&amp;key=xxxxxxxxxxxxxxxxx", //注：key为商户平台设置的密钥key sign = MD5(stringSignTemp).toUpperCase(); //注：MD5签名方式 以上就是我们所需要的一些参数签名生成算法见微信官方spbill_create_ip 是 终端ip地址 下面把所有的参数拼接成xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 const formData = "&lt;xml&gt;"; formData += "&lt;appid&gt;" + appid + "&lt;/appid&gt;"; //appid formData += "&lt;body&gt;" + body + "&lt;/body&gt;"; //商品或支付单简要描述 formData += "&lt;mch_id&gt;" + mch_id + "&lt;/mch_id&gt;"; //商户号 formData += "&lt;nonce_str&gt;" + nonce_str + "&lt;/nonce_str&gt;"; //随机字符串，不长于32位 formData += "&lt;notify_url&gt;" + notify_url + "&lt;/notify_url&gt;"; //支付成功后微信服务器通过POST请求通知这个地址 formData += "&lt;out_trade_no&gt;" + out_trade_no + "&lt;/out_trade_no&gt;"; //订单号 formData += "&lt;total_fee&gt;" + total_fee + "&lt;/total_fee&gt;"; //金额 formData += "&lt;spbill_create_ip&gt;" + ctx.request.ip + "&lt;/spbill_create_ip&gt;"; //ip formData += "&lt;trade_type&gt;NATIVE&lt;/trade_type&gt;"; //NATIVE会返回code_url ，JSAPI不会返回 formData += "&lt;sign&gt;" + sign + "&lt;/sign&gt;"; formData += "&lt;/xml&gt;"; // 这里使用了egg里面请求的方式const resultData = yield ctx.curl(url, &#123; method: 'POST', content: formData, headers: &#123; 'content-type': 'text/html', &#125;, &#125;);// xml转json格式xml2js.parseString(resultData.data, function (err, json) &#123; if (err) &#123; new Error("解析xml报错") &#125; else &#123; var result = formMessage(json.xml); // 转换成正常的json 数据 console.log(result) //打印出返回的结果 &#125;&#125;) var formMessage = function (result) &#123; var message = &#123;&#125;; if (typeof result === 'object') &#123; var keys = Object.keys(result); for (var i = 0; i &lt; keys.length; i++) &#123; var item = result[keys[i]]; var key = keys[i]; if (!(item instanceof Array) || item.length === 0) &#123; continue; &#125; if (item.length === 1) &#123; var val = item[0]; if (typeof val === 'object') &#123; message[key] = formMessage(val); &#125; else &#123; message[key] = (val || '').trim(); &#125; &#125; else &#123; message[key] = []; for (var j = 0, k = item.length; j &lt; k; j++) &#123; message[key].push(formMessage(itemp[j])); &#125; &#125; &#125; &#125; return message; &#125; 上面使用了egg的请求方式，node可以使用request123456789var request = require('request');request(&#123; url: url, method: "POST", body: formData&#125;, function(error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; &#125;&#125;); 如果请求成功会最终返回一个xml,然后我们进行解析成json的格式,里面会有一个code_url和out_trade_no,我们需要把这两个返回给前端，然后通过生成二维码展示给用户扫码，完成支付 监听支付是否成功上面操作完成之后，我们需要知道用户是否完成支付，因为用户会停留在该页面，我们需要在用户付完款之后，通知用户支付成功。首先，用户发起支付的时候我们会生成二维码，让用户完成扫码支付，我们还要做的是，开一个定时器，每隔一段时间去发送一个请求，这个时候，我们node后台就需要写一个查询订单的接口，之前我们拿到了out_trade_no，也就是我们系统内部的订单号，我们把这个数据发送给后台查询订单的接口，然后后台接收到之后会请求微信的查询接口地址https://api.mch.weixin.qq.com/pay/orderquery,流程跟上面一样，只是接口地址和微信返回的xml不一样而已，返回的字段会有一个状态即SUCCESS和NOTPAY，我们可以通过判断是否支付返回给前端，成功之后提示给用户支付成功，关闭定时器。 回调地址这个是非常重要的一环，大部分的操作其实在上面就可以完成，但是有特殊的情况，比如用户电脑断网发送不了请求，但是手机付款了，这就会导致我们记录不到用户支付的信息。这个时候回调地址就很重要了 设置回调地址微信商户中心-&gt;产品中心-&gt;开发配置-&gt;扫码支付 之后我们需要做的是后端用post来接收微信发送的异步回调信息，也是xml的格式，这里注意，如果不支持接收xml，可能会得到空的数据这里还需要注意的是，我们在保存用户支付信息的同时，得先查改订单是否支付，以免重复操作，可能会插入多条记录的情况 总结微信扫码支付坑还是有的，如果你是第一次摸索的话，下面罗列一下需要注意的地方 签名算法要写正确，不然是不会成功的，要拼接正确才行 微信返回的是xml格式的数据，我们得通过插件转成json，这样才方便获取数据 返回的code_url要给前端生成二维码用，然后需要开一个定时器查询该订单是否完成支付，最终通知用户结果 回调地址很重要，我们后端需要post接收微信返回的回调信息，然后保存信息，不过在保存用户支付信息的之前，我们得知道该订单是否已经保存过，以免重复添加。还有就是返回的是xml的数据，后端一定要保证能够接收得到，按照正常的方式是接收不了的，得额外设置。 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
        <category>微信支付</category>
        <category>egg</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>Node</tag>
        <tag>Egg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Vue2.js + Node.js 搭建一个小型的全栈项目]]></title>
    <url>%2F2017%2F09%2F08%2F%E4%BD%BF%E7%94%A8-Vue2-js-Node-js-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%B0%8F%E5%9E%8B%E7%9A%84%E5%85%A8%E6%A0%88%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[写在前面由于最近公司业务不是很忙，空闲时间比较多，于是就在纠结Vue.js（之前就学习过）和Node.js先专研哪个比较好，最终选择了先玩玩Node.js。经过一段时间的学习，就有了教程 Node+Koa2+Mysql 搭建简易博客 GitHub地址，想要了解的可以先看看，个人水平有限，希望可以帮到你。大概过来一个多月，我决定两路开工。使用Node.js给前端写接口，配备后台管理功能，先把后台搭建好。大概几天过后，后台一些简单的功能实现后，就开始用Vue.js开始搭建前台，也一直在想做点什么比较好，于是就做了个豆瓣评分类似的项目。 前端项目地址 https://github.com/wunci/vue-video前端预览 http://video.wunci.site 后端项目地址 https://github.com/wunci/video-admin后台管理 http://vue.wunci.site API接口地址 https://github.com/wunci/video-admin/blob/master/API.md 技术栈(Vue2.js + Node.js 全栈项目) 由于页面不是很多，vuex用的不多，关键掌握怎么实现就好了 vue2 + vuex + vue-router + webpack + fetch + sass + flex + svg + 阿里字体图标 运行1234567891011git clone https://github.com/wunci/vue-video.gitcd vue-videonpm install 建议使用淘宝镜像(https://npm.taobao.org/) =&gt; cnpm inpm run dev (运行项目)npm run build (打包项目)ps: 如果打包之后文件运行不了，请打包之前把路由的 mode:&apos;history&apos;注释掉，该功能去掉了url中丑陋的 # 号 功能 注册登录登出 + 验证码 密码检测，如果用户不存在则自动创建 检测是否登录，如果没有登录则不允许评论和评价 可以上传影片到后台，进行前台展示 评分功能，初始化评分可以自由设置，如果没有人like则默认显示原始评分，如果有则计算当前vide的评分 修改用户名，检测用户名是否跟其他人重复 上传头像，默认没有头像 评论功能，评论之后可以在个人中心展示，并且可以删除 搜索功能，可以搜索存在的影片，如果没有则显示无结果 自己喜欢的video和评论的内容会在个人中心显示 综上： [x] 注册 [x] 登录 [x] 登出 [x] 验证码 [x] 详情页 [x] 分类 [x] 分类影视列表 [x] 修改用户名 [x] 上传头像 [x] 评论 [x] 删除评论 [x] 搜索 [x] 个人中心数据 如果觉得对你有帮助还望关注一下，有问题可以即使提哟，觉得不错的话star一下也是可以的哟 前端线上地址项目是手机端的，请使用谷歌浏览器手机预览模式 首页默认一种类别只显示10个，可以查看更多显示全部 预览：vue-video 手机扫描图下二维码预览 后端线上地址技术栈：Node + Koa2 + Mysql预览：video-adminGitHub: 管理后台 前端演示 主页 登录页 个人中心页 详情页 后台演示 有问题欢迎反馈在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流 邮件(875246904#qq.com, 把#换成@) QQ: 875246904 weibo: @wunci 目录结构12345678910111213141516171819|-- build // webpack配置文件|-- config // 项目打包路径|-- src // 源码目录| |-- assets // 图片文件| |-- base // 移动端适配| |-- components // 组件| |-- data // 接口| |-- router // 路由配置| |-- store // 状态管理| |-- style // 样式| App.vue // 页面入口文件| main.js // 程序入口文件|-- static // 静态资源|-- .babelrc // ES6语法编译配置|-- .editorconfig // 代码编写规格|-- .gitignore // git忽略的文件|-- .postcssrc.js // post-loader的插件配置文件|-- index.html // 入口html文件|-- package.json // 项目及工具的依赖配置文件 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
        <tag>Koa</tag>
        <tag>Node</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础]]></title>
    <url>%2F2017%2F07%2F20%2FMySQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[转载自 mysql-tutorial 开始使用MySQL 为关系型数据库(Relational Database Management System)，一个关系型数据库由一个或数个表格组成, 如图所示的一个表格： 表头(header): 每一列的名称; 列(col): 具有相同数据类型的数据的集合; 行(row): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。登录MySQL 123456mysql -h 127.0.0.1 -u 用户名 -pmysql -D 所选择的数据库名 -h 主机名 -u 用户名 -pmysql&gt; exit # 退出 使用 “quit;” 或 “\q;” 一样的效果mysql&gt; status; # 显示当前mysql的version的各种信息mysql&gt; select version(); # 显示当前mysql的version信息mysql&gt; show global variables like 'port'; # 查看MySQL端口号 创建数据库对于表的操作需要先进入库use 库名; 12345678-- 创建一个名为 samp_db 的数据库，数据库字符编码指定为 gbkcreate database samp_db character set gbk;drop database samp_db; -- 删除 库名为samp_db的库show databases; -- 显示数据库列表。use samp_db; -- 选择创建的数据库samp_dbshow tables; -- 显示samp_db下面所有的表名字describe 表名; -- 显示数据表的结构delete from 表名; -- 清空表中记录 创建数据库表 使用 create table 语句可完成对表的创建, create table 的常见形式:语法：create table 表名称(列声明); 1234567891011121314-- 如果数据库中存在user_accounts表，就把它从数据库中drop掉DROP TABLE IF EXISTS `user_accounts`;CREATE TABLE `user_accounts` ( `id` int(100) unsigned NOT NULL AUTO_INCREMENT primary key, `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `reset_password` tinyint(32) NOT NULL DEFAULT 0 COMMENT '用户类型：0－不需要重置密码；1-需要重置密码', `mobile` varchar(20) NOT NULL DEFAULT '' COMMENT '手机', `create_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6), `update_at` timestamp(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6), -- 创建唯一索引，不允许重复 UNIQUE INDEX idx_user_mobile(`mobile`))ENGINE=InnoDB DEFAULT CHARSET=utf8COMMENT='用户表信息'; 数据类型的属性解释 NULL：数据列可包含NULL值； NOT NULL：数据列不允许包含NULL值； DEFAULT：默认值； PRIMARY：KEY 主键； AUTO_INCREMENT：自动递增，适用于整数类型； UNSIGNED：是指数值类型只能为正数； CHARACTER SET name：指定一个字符集； COMMENT：对表或者字段说明； 增删改查SELECT SELECT 语句用于从表中选取数据。语法：SELECT 列名称 FROM 表名称语法：SELECT * FROM 表名称 12345678910111213141516171819-- 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示idSELECT s.id from station s WHERE id in (13,14) and id not in (4);-- 从表 Persons 选取 LastName 列的数据SELECT LastName FROM Persons-- 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)SELECT * FROM users where id=3 limit 1-- 结果集中会自动去重复数据SELECT DISTINCT Company FROM Orders -- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段SELECT p.LastName, p.FirstName, o.OrderNo FROM Persons p, Orders o WHERE p.Id_P = o.Id_P -- gbk 和 utf8 中英文混合排序最简单的办法 -- ci是 case insensitive, 即 “大小写不敏感”SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using gbk) collate gbk_chinese_ci;SELECT tag, COUNT(tag) from news GROUP BY tag order by convert(tag using utf8) collate utf8_unicode_ci; UPDATE Update 语句用于修改表中的数据。语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值 12345-- update语句设置字段值为另一个结果取出来的字段update user set name = (select name from user1 where user1 .id = 1 )where id = (select id from user2 where user2 .name='小苏');-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段UPDATE `orders` set title='这里是标题' WHERE id=1; INSERT INSERT INTO 语句用于向表格中插入新的行。语法：INSERT INTO 表名称 VALUES (值1, 值2,....)语法：INSERT INTO 表名称 (列1, 列2,...) VALUES (值1, 值2,....) 123456789101112-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghaiINSERT INTO Persons (LastName, Address) VALUES ('JSLite', 'shanghai');-- 向表 meeting 插入 字段 a=1 和字段 b=2INSERT INTO meeting SET a=1,b=2;-- -- SQL实现将一个表的数据插入到另外一个表的代码-- 如果只希望导入指定字段，可以用这种方法：-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;INSERT INTO orders (user_account_id, title) SELECT m.user_id, m.title FROM meeting m where m.id=1;-- 向表 charger 插入一条数据，已存在就对表 charger 更新 `type`,`update_at` 字段；INSERT INTO `charger` (`id`,`type`,`create_at`,`update_at`) VALUES (3,2,'2017-05-18 11:06:17','2017-05-18 11:06:17') ON DUPLICATE KEY UPDATE `id`=VALUES(`id`), `type`=VALUES(`type`), `update_at`=VALUES(`update_at`); DELETE DELETE 语句用于删除表中的行。语法：DELETE FROM 表名称 WHERE 列名称 = 值 12345678-- 在不删除table_name表的情况下删除所有的行，清空表。DELETE FROM table_name-- 或者DELETE * FROM table_name-- 删除 Person表字段 LastName = 'JSLite' DELETE FROM Person WHERE LastName = 'JSLite' -- 删除 表meeting id 为2和3的两条数据DELETE from meeting where id in (2,3); WHERE WHERE 子句用于规定选择的标准。语法：SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 12-- 从表 Persons 中选出 Year 字段大于 1965 的数据SELECT * FROM Persons WHERE Year&gt;1965 AND 和 OR AND - 如果第一个条件和第二个条件都成立；OR - 如果第一个条件和第二个条件中只要有一个成立； AND1234567-- 删除 meeting 表字段 -- id=2 并且 user_id=5 的数据 和-- id=3 并且 user_id=6 的数据 DELETE from meeting where id in (2,3) and user_id in (5,6);-- 使用 AND 来显示所有姓为 "Carter" 并且名为 "Thomas" 的人：SELECT * FROM Persons WHERE FirstName='Thomas' AND LastName='Carter'; OR12-- 使用 OR 来显示所有姓为 "Carter" 或者名为 "Thomas" 的人：SELECT * FROM Persons WHERE firstname='Thomas' OR lastname='Carter' ORDER BY 语句默认按照升序对记录进行排序。ORDER BY - 语句用于根据指定的列对结果集进行排序。DESC - 按照降序对记录进行排序。ASC - 按照顺序对记录进行排序。 12345678-- Company在表Orders中为字母，则会以字母顺序显示公司名称SELECT Company, OrderNumber FROM Orders ORDER BY Company-- 后面跟上 DESC 则为降序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC-- Company以降序显示公司名称，并OrderNumber以顺序显示SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC IN IN - 操作符允许我们在 WHERE 子句中规定多个值。IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。语法：SELECT &quot;字段名&quot;FROM &quot;表格名&quot;WHERE &quot;字段名&quot; IN (&#39;值一&#39;, &#39;值二&#39;, ...); 12-- 从表 Persons 选取 字段 LastName 等于 Adams、CarterSELECT * FROM Persons WHERE LastName IN ('Adams','Carter') NOT NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。 1SELECT vend_id, prod_name FROM Products WHERE NOT vend_id = 'DLL01' ORDER BY prod_name; UNION UNION - 操作符用于合并两个或多个 SELECT 语句的结果集。 123456789-- 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名SELECT E_Name FROM Employees_China UNION SELECT E_Name FROM Employees_USA-- 列出 meeting 表中的 pic_url，-- station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错-- 按更新时间排序SELECT id,pic_url FROM meeting UNION ALL SELECT id,number_station AS pic_url FROM station ORDER BY update_at;-- 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序SELECT 'product' AS type, count(*) as count FROM `products` union select 'comment' as type, count(*) as count FROM `comments` order by count; AS as - 可理解为：用作、当成，作为；别名一般是重命名列名或者表名。语法：select column_1 as 列1,column_2 as 列2 from table as 表 12345678910111213141516SELECT * FROM Employee AS emp-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.-- 例如 SELECT * FROM emp.SELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice-- 显示表 users_profile 中的 name 列SELECT t.name from (SELECT * from users_profile a) AS t;-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id-- 结果集只显示mobile、name两列SELECT ua.mobile,up.name FROM user_accounts as ua INNER JOIN users_profile as up ON ua.id = up.user_id; JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。 JOIN: 如果表中有至少一个匹配，则返回行 INNER JOIN:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 只要其中一个表中存在匹配，就返回行 12345SELECT Persons.LastName, Persons.FirstName, Orders.OrderNoFROM PersonsINNER JOIN OrdersON Persons.Id_P = Orders.Id_PORDER BY Persons.LastName; SQL 函数COUNT COUNT 让我们能够数出在表格中有多少笔资料被选出来。语法：SELECT COUNT(&quot;字段名&quot;) FROM &quot;表格名&quot;; 1234567-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。-- "IS NOT NULL" 是 "这个栏位不是空白" 的意思。SELECT COUNT (Store_Name) FROM Store_Information WHERE Store_Name IS NOT NULL; -- 获取 Persons 表的总数SELECT COUNT(1) AS totals FROM Persons;-- 获取表 station 字段 user_id 相同的总数select user_id, count(*) as totals from station group by user_id; MAX MAX 函数返回一列中的最大值。NULL 值不包括在计算中。语法：SELECT MAX(&quot;字段名&quot;) FROM &quot;表格名&quot; 123-- 列出表 Orders 字段 OrderPrice 列最大值，-- 结果集列不显示 OrderPrice 显示 LargestOrderPriceSELECT MAX(OrderPrice) AS LargestOrderPrice FROM Orders 触发器 语法：create trigger &lt;触发器名称&gt;{ before | after} # 之前或者之后出发insert | update | delete # 指明了激活触发程序的语句的类型on &lt;表名&gt; # 操作哪张表for each row # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。&lt;触发器SQL语句&gt; 123456789101112delimiter $CREATE TRIGGER set_userdate BEFORE INSERT on `message`for EACH ROWBEGIN set @statu = new.status; -- 声明复制变量 statu if @statu = 0 then -- 判断 statu 是否等于 0 UPDATE `user_accounts` SET status=1 WHERE openid=NEW.openid; end if;END$DELIMITER ; -- 恢复结束符号 OLD和NEW不区分大小写 NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。 OLD 用OLD.col_name来引用更新前的某一行的列 添加索引普通索引(INDEX) 语法：ALTER TABLE 表名字 ADD INDEX 索引名字 ( 字段名字 ) 1234567891011121314151617-- –直接创建索引CREATE INDEX index_user ON user(title)-- –修改表结构的方式添加索引ALTER TABLE table_name ADD INDEX index_name ON (column(length))-- 给 user 表中的 name字段 添加普通索引(INDEX)ALTER TABLE `table` ADD INDEX index_name (name)-- –创建表的时候同时创建索引CREATE TABLE `table` ( `id` int(11) NOT NULL AUTO_INCREMENT , `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL , `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL , `time` int(10) NULL DEFAULT NULL , PRIMARY KEY (`id`), INDEX index_name (title(length)))-- –删除索引DROP INDEX index_name ON table 主键索引(PRIMARY key) 语法：ALTER TABLE 表名字 ADD PRIMARY KEY ( 字段名字 ) 12-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)ALTER TABLE `user` ADD PRIMARY key (id); 唯一索引(UNIQUE) 语法：ALTER TABLE 表名字 ADD UNIQUE (字段名字) 12-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)ALTER TABLE `user` ADD UNIQUE (creattime); 全文索引(FULLTEXT) 语法：ALTER TABLE 表名字 ADD FULLTEXT (字段名字) 12-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)ALTER TABLE `user` ADD FULLTEXT (description); 添加多列索引 语法：ALTER TABLE table_name ADD INDEX index_name ( column1, column2, column3) 12-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)ALTER TABLE user ADD INDEX name_city_age (name(10),city,age); 建立索引的时机在WHERE和JOIN中出现的列需要建立索引，但也不完全如此： MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN使用索引 某些时候的LIKE也会使用索引。 在LIKE以通配符%和_开头作查询时，MySQL不会使用索引。 12345678-- 此时就需要对city和age建立索引，-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city='上海';SELECT * FROM mytable WHERE username like'admin%'; -- 而下句就不会使用：SELECT * FROM mytable WHEREt Name like'%admin'; -- 因此，在使用LIKE时应注意以上的区别。 索引的注意事项 索引不会包含有NULL值的列 使用短索引 不要在列上进行运算 索引会失效 创建后表的修改添加列 语法：alter table 表名 add 列名 列数据类型 [after 插入位置]; 示例: 123456-- 在表students的最后追加列 address: alter table students add address char(60);-- 在名为 age 的列后插入列 birthday: alter table students add birthday date after age;-- 在名为 number_people 的列后插入列 weeks: alter table students add column `weeks` varchar(5) not null default "" after `number_people`; 修改列 语法：alter table 表名 change 列名称 列新名称 新数据类型; 123456789-- 将表 tel 列改名为 telphone: alter table students change tel telphone char(13) default "-";-- 将 name 列的数据类型改为 char(16): alter table students change name name char(16) not null;-- 修改 COMMENT 前面必须得有类型属性alter table students change name name char(16) COMMENT '这里是名字';-- 修改列属性的时候 建议使用modify,不需要重建表-- change用于修改列名字，这个需要重建表alter table meeting modify `weeks` varchar(20) NOT NULL DEFAULT "" COMMENT "开放日期 周一到周日：0~6，间隔用英文逗号隔开"; 删除列 语法：alter table 表名 drop 列名称; 12-- 删除表students中的 birthday 列: alter table students drop birthday; 重命名表 语法：alter table 表名 rename 新表名; 12-- 重命名 students 表为 workmates: alter table students rename workmates; 清空表数据 方法一：delete from 表名;方法二：truncate from &quot;表名&quot;; DELETE:1. DML语言;2. 可以回退;3. 可以有条件的删除; TRUNCATE:1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。 1234-- 清空表为 workmates 里面的数据，不删除表。 delete from workmates;-- 删除workmates表中的所有数据，且无法恢复truncate from workmates; 删除整张表 语法：drop table 表名; 12-- 删除 workmates 表: drop table workmates; 删除整个数据库 语法：drop database 数据库名; 12-- 删除 samp_db 数据库: drop database samp_db; 个人小程序]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库 （三）]]></title>
    <url>%2F2017%2F07%2F18%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93-%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本篇着重讲选择器$()选择器本例我们主要修改wunci.init=function(selector){}里面的代码将wunci.init代码修改为：1234567891011121314151617181920var domif (!selector) return wunci.Z()else if (typeof selector == 'string') &#123; dom = wunci.qsa(document, selector)&#125;else if (typeof selector == 'function')&#123; return wunci.ready(selector)&#125;else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wunci.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wunci.qsa(document,selector) &#125;&#125;return wunci.Z(dom, selector) 首先判断是否存在selector，如果不存在则直接return 然后判断是否是字符串类型，如$(&#39;a b&#39;)，将选择的元素保存起来 如果是函数则return wunci.ready(selector)就是我们经常用的$(function(){}) 后面判断是否是当前对象的实例（用了isZ方法）还有判断是否是数组或对象 我们先在函数顶部添加如下123emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filterslice = emptyArray.slicefunction compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; emptyArray = []，避免出现每次都重复创建的一个数组[]然后拿到数组里面的方法compact就是一个数组筛选，如果某个元素不存在$([1,2,,,4]);只会创建一个[1,2,4]的数组 wunci.qsa方法1234567891011121314151617wunci.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all )&#125; 这里我直接用了zepto的代码wunci.init=function(selector){}里的代码还使用了判断数据类型的代码isArray`isObject` 判断数据类型在函数外面添加如下代码来进行数据类型判断 123456789101112// 判断类型var obj_i=&#123;&#125;;['Boolean', 'Number','String', 'Function', 'Array' ,'Date', 'RegExp', 'Object' ,'Error'].forEach(function(el,idx)&#123; obj_i["[object " + el + "]"] = el.toLowerCase()&#125;)function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || "object"&#125;function isObject(obj) &#123; return type(obj) == "object" &#125; function isArray(obj) &#123; return type(obj) == "array" &#125;function isString(obj) &#123; return type(obj) == "string" &#125; wunci.ready函数在外面设置如下函数123456wunci.ready = function(fn) &#123; document.addEventListener('DOMContentLoaded',function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener('DOMContentLoaded',fn,true);&#125;; wunci.isZ函数下面代码判断object是不是wunci.Z的实例123wunci.isZ = function(object) &#123; return object instanceof wunci.Z&#125; 现在试试代码吧，我们顺便把addClass里判断hasClass代码注释去掉了 123456789101112&lt;script&gt; // ready $(function()&#123; alert(1) &#125;) // addClass $('p').addClass('a b') // 实例 console.log($(this)) // 数组 $([1,23,3,,4])&lt;/script&gt; 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131(function()&#123; var wunci = &#123;&#125;,$ emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter slice = emptyArray.slice function compact(array) &#123; return filter.call(array, function(item)&#123; return item != null &#125;) &#125; $ = function(selector)&#123; return wunci.init(selector) &#125; wunci.init = function(selector)&#123; var dom if (!selector) return wunci.Z() else if (typeof selector == 'string') &#123; dom = wunci.qsa(document, selector) &#125; else if (typeof selector == 'function')&#123; return wunci.ready(selector) &#125; else&#123; if (isArray(selector)) &#123; dom = compact(selector) &#125; else if (wunci.isZ(selector)) return selector else&#123; if (isObject(selector)) dom = [selector], selector = null ; else dom=wunci.qsa(document,selector) &#125; &#125; return wunci.Z(dom, selector) &#125; wunci.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123; var klass = node.className || '' if (value === undefined) return klass node.className = value &#125; wunci.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; wunci.ready = function(fn) &#123; document.addEventListener('DOMContentLoaded',function() &#123; fn &amp;&amp; fn(); &#125;,false); document.removeEventListener('DOMContentLoaded',fn,true); &#125;; wunci.qsa=function(element, selector)&#123; var found, maybeID = selector[0] == '#', maybeClass = !maybeID &amp;&amp; selector[0] == '.', nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked isSimple = /^[\w-]*$/.test(nameOnly) return (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? // Safari DocumentFragment doesn't have getElementById ( (found = element.getElementById(nameOnly)) ? [found] : [] ) : (element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 &amp;&amp; element.nodeType !== 11) ? [] : slice.call( isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class element.getElementsByTagName(selector) : // Or a tag element.querySelectorAll(selector) // Or it's not simple, and we need to query all ) &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; wunci.isZ = function(object) &#123; return object instanceof wunci.Z &#125; // 判断类型 var obj_i=&#123;&#125;; ['Boolean', 'Number','String', 'Function', 'Array' ,'Date', 'RegExp', 'Object' ,'Error'].forEach(function(el,idx)&#123; obj_i["[object " + el + "]"] = el.toLowerCase() &#125;) function type(obj) &#123; return obj == null ? String(obj) : obj_i[Object.prototype.toString.call(obj)] || "object" &#125; function isObject(obj) &#123; return type(obj) == "object" &#125; function isArray(obj) &#123; return type(obj) == "array" &#125; function isString(obj) &#123; return type(obj) == "string" &#125; window.$ = window.wunci = $&#125;)()]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（二）]]></title>
    <url>%2F2017%2F07%2F17%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[距离上一篇zepto源码分析已经过去大半个月，想想自己都过意不去，不过之前分享了一篇node博客教程，还算干了点正事。接下来我们继续封装自己的库吧 上节代码概览12345678910111213141516171819202122232425262728293031323334(function()&#123; var wunci = &#123;&#125;,$ $ = function(selector)&#123; return wunci.init(selector) &#125; wunci.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wunci.Z(dom,selector) &#125; wunci.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wunci.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wunci = $&#125;)() each方法 在wunci.Z.prototype=Z.prototype=里面添加方法each 12345678wunci.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;&#125; 通过数组的every方法进行遍历，然后看看每次callback是不是都不是false，如果是则结束遍历 最后通过 return this 来达到链式调用的效果 addClass方法继续在里面添加addClass方法 123456789101112131415161718addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) // newName = funcArg(this, name, idx, cls) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;)&#125; 我们先判断name存在与否，没有就直接return this，支持链式调用 新建一个数组，存放我们要添加的class，因为可能要同时添加多个 通过调用className方法来获取之前的class，并保存起来。clasName方法在下面 我们添加class一般是这样addClass(&#39;a b c&#39;)，所以我们通过正则表达式把他们用空格分开/\s+/g,用+的原因是，可能会有多个空格的存在，接着对他们进行循环 通过hasClass判断之前是否已经存在需要添加的class，如果有就push到classList数组里面。我们先注释掉hasClass这段代码，因为其中用到了$(this) ,querySelector是不支持的哟，所以后面我们得作判断，判断$()这里面放的是元素、函数、类数组等等。 最后通过函数className方法把他们用空格连接起来 发现里面有一个没有声明的className方法所以我们在wunci.Z.prototype=Z.prototype=上面声明该函数1234567//获取或者设置classfunction className(node, value)&#123; var klass = node.className || '' if (value === undefined) return klass node.className = value&#125; 该方法主要是获取class和设置class的作用 hasClass方法12345678hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this;&#125; 通过正则匹配，如果存在则返回true，否则返回false，最后return this支持链式调用 现在来试试效果吧12345html: &lt;p class="a"&gt;&lt;/p&gt;js: $('p').addClass('test other') // &lt;p class="a test other"&gt;&lt;/p&gt; console.log($('p').hasClass('a')) // true 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function()&#123; var wunci = &#123;&#125;,$ $ = function(selector)&#123; return wunci.init(selector) &#125; wunci.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wunci.Z(dom,selector) &#125; wunci.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; function className(node, value)&#123;//获取或者设置class var klass = node.className || '' if (value === undefined) return klass node.className = value &#125; wunci.Z.prototype = Z.prototype = &#123; each:function(callback)&#123; [].every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this; &#125;, addClass:function(name)&#123; if (!name) return this return this.each(function(el,idx)&#123; if (!('className' in this)) return classList = []; var cls = className(this) name.split(/\s+/g).forEach(function(klass)&#123; // if (!$(this).hasClass(klass)) classList.push(klass) &#125;, this) classList.length &amp;&amp; className(this, cls + (cls ? " " : "") + classList.join(" ")) &#125;) &#125;, hasClass : function(cls) &#123; var reg = new RegExp('(\\s|^)' + cls + '(\\s|$)'); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i].className.match(reg)) return true; return false; &#125; return this; &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wunci = $&#125;)()]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node+Koa2+Mysql 搭建简易博客]]></title>
    <url>%2F2017%2F07%2F12%2FNode-Koa2-Mysql-%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Koa2-blog 2018-1-5 更新教程（新增上传头像、新增分页、样式改版、发布文章和评论支持markdown语法）现在GitHub的代码结构有变，优化了蛮多东西 Node+Koa2+Mysql 搭建简易博客 预览地址http://blog.wunci.site 写在前面本篇教程一方面是为了自己在学习的过程加深记忆，也是总结的过程。另一方面给对这方面不太了解的同学以借鉴经验。如发现问题还望指正，如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wunci/Koa2-blog下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ps：关于markdown代码缩进问题，看起来不太舒服，但复制到编辑器是正常的哟！ 演示效果 开发环境 nodejs v8.1.0 koa v2.3.0 mysql v5.7.0 准备工作文中用到了promise、async await等语法，所以你需要一点es6的语法，传送门当然是阮老师的教程了 http://es6.ruanyifeng.com/ 如果你已经配置好node和mysql可以跳过 经常会有人问报错的问题，运行出错大部分是因为不支持async，升级node版本可解决 1$ node -v 查看你的node版本，如果过低则去nodejs官网下载替换之前的版本 下载mysql，并设置好用户名和密码，默认可以为用户名：root，密码：123456 1进入到 bin 目录下 比如 cd C:\Program Files\MySQL\MySQL Server 5.7\bin 然后开启mysql1$ mysql -u root -p 输入密码之后创建database(数据库)，nodesql是我们创建的数据库1$ create database nodesql; 记住sql语句后面一定要跟;符号，接下来看看我们创建好的数据库列表 1$ show databases; 启用创建的数据库1$ use nodesql; 查看数据库中的表1$ show tables; 显示Empty set (0.00 sec)，因为我们还没有建表，稍后会用代码建表注释：这是后面建表之后的状态 目录结构 config 存放默认文件 lib 存放操作数据库文件 middlewares 存放判断登录与否文件 public 存放样式和头像文件 routes 存放路由文件 views 存放模板文件 index 程序主文件 package.json 包括项目名、作者、依赖等等 首先我们创建koa2-blog文件夹，然后cd koa2-blog1接着使用 npm init 来创建package.json 接着安装包，安装之前我们使用cnpm安装1$ npm install -g cnpm --registry=https://registry.npm.taobao.org 1$ cnpm i koa koa-bodyparser koa-mysql-session koa-router koa-session-minimal koa-static koa-views md5 moment mysql ejs markdown-it chai mocha koa-static-cache --save-dev 各模块用处 koa node框架 koa-bodyparser 表单解析中间件 koa-mysql-session、koa-session-minimal 处理数据库的中间件 koa-router 路由中间件 koa-static 静态资源加载中间件 ejs 模板引擎 md5 密码加密 moment 时间中间件 mysql 数据库 markdown-it markdown语法 koa-views 模板呈现中间件 chai mocha 测试使用 koa-static-cache 文件缓存 在文件夹里面新建所需文件 首先配置config我们新建default.js文件 123456789101112131415const config = &#123; // 启动端口 port: 3000, // 数据库配置 database: &#123; DATABASE: &apos;nodesql&apos;, USERNAME: &apos;root&apos;, PASSWORD: &apos;123456&apos;, PORT: &apos;3306&apos;, HOST: &apos;localhost&apos; &#125;&#125;module.exports = config 这是我们所需的一些字段，包括端口和数据库连接所需，最后我们把它exports暴露出去，以便可以在别的地方使用 配置index.js文件index.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const Koa=require('koa');const path=require('path')const bodyParser = require('koa-bodyparser');const ejs=require('ejs');const session = require('koa-session-minimal');const MysqlStore = require('koa-mysql-session');const config = require('./config/default.js');const router=require('koa-router')const views = require('koa-views')// const koaStatic = require('koa-static')const staticCache = require('koa-static-cache')const app = new Koa()// session存储配置const sessionMysqlConfig= &#123; user: config.database.USERNAME, password: config.database.PASSWORD, database: config.database.DATABASE, host: config.database.HOST,&#125;// 配置session中间件app.use(session(&#123; key: 'USER_SID', store: new MysqlStore(sessionMysqlConfig)&#125;))// 配置静态资源加载中间件// app.use(koaStatic(// path.join(__dirname , './public')// ))// 缓存app.use(staticCache(path.join(__dirname, './public'), &#123; dynamic: true &#125;, &#123; maxAge: 365 * 24 * 60 * 60&#125;))app.use(staticCache(path.join(__dirname, './images'), &#123; dynamic: true &#125;, &#123; maxAge: 365 * 24 * 60 * 60&#125;))// 配置服务端模板渲染引擎中间件app.use(views(path.join(__dirname, './views'), &#123; extension: 'ejs'&#125;))app.use(bodyParser(&#123; formLimit: '1mb'&#125;))// 路由(我们先注释三个，等后面添加好了再取消注释，因为我们还没有定义路由，稍后会先实现注册)//app.use(require('./routers/signin.js').routes())app.use(require('./routers/signup.js').routes())//app.use(require('./routers/posts.js').routes())//app.use(require('./routers/signout.js').routes())app.listen(3000)console.log(`listening on port $&#123;config.port&#125;`) 我们使用koa-session-minimal`koa-mysql-session来进行数据库的操作 使用koa-static配置静态资源，目录设置为public使用ejs模板引擎 使用koa-bodyparser来解析提交的表单信息 使用koa-router做路由 使用koa-static-cache`来缓存文件之前我们配置了default.js，我们就可以在这里使用了首先引入进来 var config = require(‘./config/default.js’);然后在数据库的操作的时候，如config.database.USERNAME，得到的就是root。 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wunci/Koa2-blog 配置lib的mysql.js文件关于数据库的使用这里介绍一下，首先我们建立了数据库的连接池，以便后面的操作都可以使用到，我们创建了一个函数query，通过返回promise的方式以便可以方便用.then()来获取数据库返回的数据，然后我们定义了三个表的字段，通过createTable来创建我们后面所需的三个表，包括posts(存储文章)，users(存储用户)，comment(存储评论)，create table if not exists users()表示如果users表不存在则创建该表，避免每次重复建表报错的情况。后面我们定义了一系列的方法，最后把他们exports暴露出去。 这里只介绍注册用户insertData，后续的可以自行查看，都差不多 12345// 注册用户let insertData = function( value ) &#123; let _sql = "insert into users set name=?,pass=?,avator=?,moment=?;" return query( _sql, value )&#125; 我们写了一个_sql的sql语句，意思是插入到users的表中（在这之前我们已经建立了users表）然后要插入的数据分别是name、pass、avator、moment，就是用户名、密码、头像、注册时间，最后调用query函数把sql语句传进去（之前的写法是&quot;insert into users(name,pass) values(?,?);&quot;,换成现在得更容易理解） lib/mysql.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225var mysql = require('mysql');var config = require('../config/default.js')var pool = mysql.createPool(&#123; host : config.database.HOST, user : config.database.USERNAME, password : config.database.PASSWORD, database : config.database.DATABASE&#125;);let query = function( sql, values ) &#123; return new Promise(( resolve, reject ) =&gt; &#123; pool.getConnection(function(err, connection) &#123; if (err) &#123; reject( err ) &#125; else &#123; connection.query(sql, values, ( err, rows) =&gt; &#123; if ( err ) &#123; reject( err ) &#125; else &#123; resolve( rows ) &#125; connection.release() &#125;) &#125; &#125;) &#125;)&#125;// let query = function( sql, values ) &#123;// pool.getConnection(function(err, connection) &#123;// // 使用连接// connection.query( sql,values, function(err, rows) &#123;// // 使用连接执行查询// console.log(rows)// connection.release();// //连接不再使用，返回到连接池// &#125;);// &#125;);// &#125;let users = `create table if not exists users( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, pass VARCHAR(100) NOT NULL, avator VARCHAR(100) NOT NULL, moment VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let posts = `create table if not exists posts( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, title TEXT(0) NOT NULL, content TEXT(0) NOT NULL, md TEXT(0) NOT NULL, uid VARCHAR(40) NOT NULL, moment VARCHAR(100) NOT NULL, comments VARCHAR(200) NOT NULL DEFAULT '0', pv VARCHAR(40) NOT NULL DEFAULT '0', avator VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let comment = `create table if not exists comment( id INT NOT NULL AUTO_INCREMENT, name VARCHAR(100) NOT NULL, content TEXT(0) NOT NULL, moment VARCHAR(40) NOT NULL, postid VARCHAR(40) NOT NULL, avator VARCHAR(100) NOT NULL, PRIMARY KEY ( id ) );`let createTable = function( sql ) &#123; return query( sql, [] )&#125;// 建表createTable(users)createTable(posts)createTable(comment)// 注册用户let insertData = function( value ) &#123; let _sql = "insert into users set name=?,pass=?,avator=?,moment=?;" return query( _sql, value )&#125;// 删除用户let deleteUserData = function( name ) &#123; let _sql = `delete from users where name="$&#123;name&#125;";` return query( _sql )&#125;// 查找用户let findUserData = function( name ) &#123; let _sql = `select * from users where name="$&#123;name&#125;";` return query( _sql )&#125;// 发表文章let insertPost = function( value ) &#123; let _sql = "insert into posts set name=?,title=?,content=?,md=?,uid=?,moment=?,avator=?;" return query( _sql, value )&#125;// 更新文章评论数let updatePostComment = function( value ) &#123; let _sql = "update posts set comments=? where id=?" return query( _sql, value )&#125;// 更新浏览数let updatePostPv = function( value ) &#123; let _sql = "update posts set pv=? where id=?" return query( _sql, value )&#125;// 发表评论let insertComment = function( value ) &#123; let _sql = "insert into comment set name=?,content=?,moment=?,postid=?,avator=?;" return query( _sql, value )&#125;// 通过名字查找用户let findDataByName = function ( name ) &#123; let _sql = `select * from users where name="$&#123;name&#125;";` return query( _sql)&#125;// 通过文章的名字查找用户let findDataByUser = function ( name ) &#123; let _sql = `select * from posts where name="$&#123;name&#125;";` return query( _sql)&#125;// 通过文章id查找let findDataById = function ( id ) &#123; let _sql = `select * from posts where id="$&#123;id&#125;";` return query( _sql)&#125;// 通过评论id查找let findCommentById = function ( id ) &#123; let _sql = `select * FROM comment where postid="$&#123;id&#125;";` return query( _sql)&#125;// 查询所有文章let findAllPost = function () &#123; let _sql = ` select * FROM posts;` return query( _sql)&#125;// 查询分页文章let findPostByPage = function (page) &#123; let _sql = ` select * FROM posts limit $&#123;(page-1)*10&#125;,10;` return query( _sql)&#125;// 查询个人分页文章let findPostByUserPage = function (name,page) &#123; let _sql = ` select * FROM posts where name="$&#123;name&#125;" order by id desc limit $&#123;(page-1)*10&#125;,10 ;` return query( _sql)&#125;// 更新修改文章let updatePost = function(values)&#123; let _sql = `update posts set title=?,content=?,md=? where id=?` return query(_sql,values)&#125;// 删除文章let deletePost = function(id)&#123; let _sql = `delete from posts where id = $&#123;id&#125;` return query(_sql)&#125;// 删除评论let deleteComment = function(id)&#123; let _sql = `delete from comment where id=$&#123;id&#125;` return query(_sql)&#125;// 删除所有评论let deleteAllPostComment = function(id)&#123; let _sql = `delete from comment where postid=$&#123;id&#125;` return query(_sql)&#125;// 查找评论数let findCommentLength = function(id)&#123; let _sql = `select content from comment where postid in (select id from posts where id=$&#123;id&#125;)` return query(_sql)&#125;// 滚动无限加载数据let findPageById = function(page)&#123; let _sql = `select * from posts limit $&#123;(page-1)*5&#125;,5;` return query(_sql)&#125;// 评论分页let findCommentByPage = function(page,postId)&#123; let _sql = `select * from comment where postid=$&#123;postId&#125; order by id desc limit $&#123;(page-1)*10&#125;,10;` return query(_sql)&#125;module.exports = &#123; query, createTable, insertData, deleteUserData, findUserData, findDataByName, insertPost, findAllPost, findPostByPage, findPostByUserPage, findDataByUser, findDataById, insertComment, findCommentById, updatePost, deletePost, deleteComment, findCommentLength, updatePostComment, deleteAllPostComment, updatePostPv, findPageById, findCommentByPage&#125; 下面是我们建的表 users posts comment id id id name name name pass title content avator content moment moment md postid - uid avator - moment - - comments - - pv - - avator - id主键递增 name: 用户名 pass：密码 avator：头像 title：文章标题 content：文章内容和评论 md：markdown语法 uid：发表文章的用户id moment：创建时间 comments：文章评论数 pv：文章浏览数 postid：文章id 现在感觉有点枯燥，那我们先来实现一下注册吧 实现注册页面routers/singup.js12345678910111213141516const router = require('koa-router')();const userModel = require('../lib/mysql.js');const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginconst moment = require('moment');const fs = require('fs')// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;) module.exports = router 使用get方式得到’/signup’页面，然后渲染signup模板，这里我们还没有在写signup.ejs views/signup.ejs 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="请输入用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="请输入密码" class="password" type="password" name="password"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input placeholder="请确认密码" class="repeatpass" type="password" name="repeatpass"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;上传头像：&lt;/label&gt; &lt;input type="file" name="avator" id="avator"&gt; &lt;input type="hidden" id="avatorVal"&gt; &lt;img class="preview" alt="预览头像"&gt; &lt;/div&gt; &lt;div class="submit"&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们先安装supervisor 1$ cnpm i supervisor -g supervisor的作用是会监听文件的变化，而我们修改文件之后不必去重启程序1supervisor --harmony index 现在访问 localhost:3000/signup 看看效果吧。注意数据库一定要是开启的状态，不能关闭 完善注册功能首先我们来完善一下样式吧，稍微美化一下 public/index.css 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360body,header,ul,li,p,div,html,span,h3,a,blockquote &#123; margin: 0; padding: 0; color: #333;&#125;body &#123; margin-bottom: 20px;&#125;ul,li&#123; list-style-type: none;&#125;a &#123; text-decoration: none;&#125;header &#123; width: 60%; margin: 20px auto;&#125;header:after&#123; content: ''; clear: both; display: table;&#125;header .user_right&#123; float: right&#125;header .user_right .active&#123; color: #5FB878; background: #fff; border: 1px solid #5FB878; box-shadow: 0 5px 5px #ccc;&#125;header .user_name &#123; float: left&#125;.user_name &#123; font-size: 20px;&#125;.has_user a,.has_user span,.none_user a &#123; padding: 5px 15px; background: #5FB878; border-radius: 15px; color: #fff; cursor: pointer; border: 1px solid #fff; transition: all 0.3s;&#125;.has_user a:hover,.has_user span:hover&#123; color: #5FB878; background: #fff; border: 1px solid #5FB878; box-shadow: 0 5px 5px #ccc;&#125;.posts&#123; border-radius: 4px; border: 1px solid #ddd;&#125;.posts &gt; li&#123; padding: 10px; position: relative; padding-bottom: 40px;&#125;.posts .comment_pv&#123; position: absolute; bottom: 5px; right: 10px;&#125;.posts .author&#123; position: absolute; left: 10px; bottom: 5px;&#125;.posts .author span&#123; margin-right: 5px;&#125;.posts &gt; li:hover &#123; background: #f2f2f2;&#125;.posts &gt; li:hover pre&#123; border: 1px solid #666;&#125;.posts &gt; li:hover .content&#123; border-top: 1px solid #fff; border-bottom: 1px solid #fff;&#125;.posts &gt; li + li&#123; border-top: 1px solid #ddd;&#125;.posts li .title span&#123; position: absolute; left: 10px; top: 10px; color: #5FB878; font-size: 14px;&#125;.posts li .title&#123; margin-left: 40px; font-size: 20px; color: #222;&#125;.posts .userAvator&#123; position: absolute; left: 3px; top: 3px; width: 40px; height: 40px; border-radius: 5px;&#125;.posts .content&#123; border-top: 1px solid #f2f2f2; border-bottom: 1px solid #f2f2f2; margin: 10px 0 0 0 ; padding: 10px 0; margin-left: 40px;&#125;.userMsg img&#123; width: 40px; height: 40px; border-radius: 5px; margin-right: 10px; vertical-align: middle; display: inline-block;&#125;.userMsg span&#123; font-size: 18px; color:#333; position: relative; top: 2px;&#125;.posts li img&#123; max-width: 100%;&#125;.spost .comment_pv&#123; position: absolute; top: 10px;&#125;.spost .edit &#123; position: absolute; right: 20px; bottom: 5px;&#125;.spost .edit p &#123; display: inline-block; margin-left: 10px;&#125;.comment_wrap &#123; width: 60%; margin: 20px auto;&#125;.submit &#123; display: block; width: 100px; height: 40px; line-height: 40px; text-align: center; border-radius: 4px; background: #5FB878; cursor: pointer; color: #fff; float: left; margin-top: 20px ; border:1px solid #fff;&#125;.submit:hover&#123; background: #fff; color: #5FB878; border:1px solid #5FB878;&#125;.comment_list&#123; border: 1px solid #ddd; border-radius: 4px;&#125;.cmt_lists:hover&#123; background: #f2f2f2;&#125;.cmt_lists + .cmt_lists&#123; border-top: 1px solid #ddd;&#125;.cmt_content &#123; padding: 10px; position: relative; border-radius: 4px; word-break: break-all;&#125;.cmt_detail&#123; margin-left: 48px;&#125;.cmt_content img&#123; max-width: 100%;&#125;/* .cmt_content:after &#123; content: '#content'; position: absolute; top: 5px; right: 5px; color: #aaa; font-size: 13px;&#125; */.cmt_name &#123; position: absolute; right: 8px; bottom: 5px; color: #333;&#125;.cmt_name a &#123; margin-left: 5px; color: #1E9FFF;&#125;.cmt_time&#123; position: absolute; font-size: 12px; right: 5px; top: 5px; color: #aaa&#125;.form &#123; margin: 0 auto; width: 50%; margin-top: 20px;&#125;textarea &#123; width: 100%; height: 150px; padding:10px 0 0 10px; font-size: 20px; border-radius: 4px; border: 1px solid #d7dde4; -webkit-appearance: none; resize: none;&#125;textarea#spContent&#123; width: 98%;&#125;.tips &#123; margin: 20px 0; color: #ec5051; text-align: center;&#125;.container &#123; width: 60%; margin: 0 auto;&#125;.form img.preview &#123; width:100px; height:100px; border-radius: 50%; display: none; margin-top:10px;&#125;input &#123; display: block; width: 100%; height: 35px; font-size: 18px; padding: 6px 7px; border-radius: 4px; border: 1px solid #d7dde4; -webkit-appearance: none;&#125;input:focus,textarea:focus&#123; outline: 0; box-shadow: 0 0 0 2px rgba(51,153,255,.2); border-color: #5cadff;&#125;input:hover,input:active,textarea:hover,textarea:active&#123; border-color: #5cadff;&#125;.create label &#123; display: block; margin: 10px 0;&#125;.comment_wrap form &#123; width: 100%; margin-bottom: 85px;&#125;.delete_comment,.delete_post &#123; cursor: pointer;&#125;.delete_comment:hover,.delete_post:hover,a:hover &#123; color: #ec5051;&#125;.disabled&#123; user-select: none; cursor: not-allowed !important;&#125;.error&#123; color: #ec5051;&#125;.success&#123; color: #1E9FFF;&#125;.container&#123; width: 60%; margin:0 auto;&#125;.message&#123; position: fixed; top: -100%; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(0, 0, 0, 0.7); color: #fff; border-bottom-left-radius: 15px; border-bottom-right-radius: 15px; z-index: 99999;&#125;.markdown pre&#123; display: block; overflow-x: auto; padding: 0.5em; background: #F0F0F0; border-radius: 3px; border: 1px solid #fff;&#125;.markdown blockquote&#123; padding: 0 1em; color: #6a737d; border-left: 0.25em solid #dfe2e5; margin: 10px 0;&#125;.markdown ul li&#123; list-style: circle; margin-top: 5px;&#125; 我们再把模板引擎的header和footer独立出来 /views/header.ejs顺便引入index.css和jq123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;koa2-blog&lt;/title&gt; &lt;link rel="icon" href="http://wunci.github.io/images/avatar.png"&gt; &lt;link rel="stylesheet" href="/index.css"&gt; &lt;script src="http://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; function fade(txt)&#123; $('.message').text(txt) $('.message').animate(&#123; top:0 &#125;) setTimeout(function()&#123; $('.message').animate(&#123; top: '-100%' &#125;) &#125;,1500) &#125; $(function()&#123; $('.signout').click(()=&gt;&#123; $.ajax(&#123; url: "/signout", type: "GET", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('登出成功') setTimeout(()=&gt;&#123; window.location.href = "/posts" &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125;) &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;header&gt; &lt;div class="user_name"&gt; &lt;% if(session.user)&#123; %&gt; Hello,&lt;%= session.user %&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; 欢迎注册登录^_^ &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class="message"&gt;登录成功&lt;/div&gt; &lt;div class="user_right"&gt; &lt;% if(session.user)&#123; %&gt; &lt;div class="has_user"&gt; &lt;a target="__blank" href="https://github.com/wunci/Koa2-blog"&gt;GitHub&lt;/a&gt; &lt;% if(type == 'all')&#123; %&gt; &lt;a class="active" href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'my')&#123; %&gt; &lt;a class="active" href="/posts?author=&lt;%= session.user %&gt;"&gt;我的文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts?author=&lt;%= session.user %&gt;"&gt;我的文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'create')&#123; %&gt; &lt;a class="active" href="/create"&gt;发表文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/create"&gt;发表文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;span class="signout"&gt;登出&lt;/span&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if(!session.user)&#123; %&gt; &lt;div class="none_user has_user"&gt; &lt;a target="__blank" href="https://github.com/wunci/Koa2-blog"&gt;GitHub&lt;/a&gt; &lt;% if(type == 'all')&#123; %&gt; &lt;a class="active" href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/posts"&gt;全部文章&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'signup')&#123; %&gt; &lt;a class="active" href="/signup"&gt;注册&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/signup"&gt;注册&lt;/a&gt; &lt;% &#125;%&gt; &lt;% if(type == 'signin')&#123; %&gt; &lt;a class="active" href="/signin"&gt;登录&lt;/a&gt; &lt;% &#125;else&#123; %&gt; &lt;a href="/signin"&gt;登录&lt;/a&gt; &lt;% &#125;%&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/header&gt; 首先我们看到用到了session.user，这个值从哪来呢？请看下面的代码1234567// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;) 我们可以看到我们向模板传了一个session值，session:ctx.session，这个值存取的就是用户的信息，包括用户名、登录之后的id等，session一般是你关闭浏览器就过期了，等于下次打开浏览器的时候就得重新登录了，用if判断他存不存在，就可以知道用户是否需要登录，如果不存在用户，则只显示全部文章 注册 登录 ,如果session.user存在则有登出的按钮。 在上面我们会看到我用了另外一个if判断，判断type类型，这样做的目的是比如我们登录注册页面，注册页面的导航会高亮，其实就是添加了class：active;之后我们每个ejs文件的头部会这样写&lt;%- include(&quot;header&quot;,{type:&#39;signup&#39;}) %&gt; 登录页面则是&lt;%- include(&quot;header&quot;,{type:&#39;signin&#39;}) %&gt; /views/footer.ejs123 &lt;/body&gt;&lt;/html&gt; 修改views/signup.ejs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;%- include("header",&#123;type:'signup'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="请输入用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="请输入密码" class="password" type="password" name="password"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;重复密码：&lt;/label&gt; &lt;input placeholder="请确认密码" class="repeatpass" type="password" name="repeatpass"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;上传头像：&lt;/label&gt; &lt;input type="file" name="avator" id="avator"&gt; &lt;input type="hidden" id="avatorVal"&gt; &lt;img class="preview" alt="预览头像"&gt; &lt;/div&gt; &lt;div class="submit"&gt;注册&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(window).keyup(function (e) &#123; //console.log(e.keyCode) if (e.keyCode == 13) &#123; $('.submit').click() &#125; &#125;) $('#avator').change(function()&#123; if (this.files.length != 0) &#123; var file = this.files[0], reader = new FileReader(); if (!reader) &#123; this.value = ''; return; &#125;; console.log(file.size) if (file.size &gt;= 1024 * 1024 / 2) &#123; fade("请上传小于512kb的图片!") return &#125; reader.onload = function (e) &#123; this.value = ''; $('form .preview').attr('src', e.target.result) $('form .preview').fadeIn() $('#avatorVal').val(e.target.result) &#125;; reader.readAsDataURL(file); &#125;; &#125;) $('.submit').click(()=&gt;&#123; // console.log($('.form').serialize()) if ($('input[name=name]').val().trim() == '') &#123; fade('请输入用户名！') &#125;else if($('input[name=name]').val().match(/[&lt;'"&gt;]/g))&#123; fade('请输入合法字符！') &#125;else if($('#avatorVal').val() == '')&#123; fade('请上传头像！') &#125;else&#123; $.ajax(&#123; url: "/signup", data: &#123; name: $('input[name=name]').val(), password: $('input[name=password]').val(), repeatpass: $('input[name=repeatpass]').val(), avator: $('#avatorVal').val(), &#125;, type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg.data == 1) &#123; $('input').val('') fade('用户名存在') &#125; else if (msg.data == 2)&#123; fade('请输入重复的密码') &#125; else if(msg.data == 3)&#123; fade('注册成功') setTimeout(()=&gt;&#123; window.location.href="/signin" &#125;,1000) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) &lt;/script&gt;&lt;% include footer %&gt; 先看我们请求的url地址，是’/signup’，为什么是这个呢？我们看下面这段代码(后面有完整的)12345678910router.post('/signup', async(ctx, next) =&gt; &#123; //console.log(ctx.request.body) let user = &#123; name: ctx.request.body.name, pass: ctx.request.body.password, repeatpass: ctx.request.body.repeatpass, avator: ctx.request.body.avator &#125; ....&#125; 我们的请求方式是post，地址是/signup所以走了这段代码，之后会获取我们输入的信息，通过ctx.request.body拿到 这里重点就在于ajax提交了，提交之后换回数据 1 2 3，然后分别做正确错误处理，把信息写在error和success中 修改routers/signup.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const router = require('koa-router')();const userModel = require('../lib/mysql.js');const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginconst moment = require('moment');const fs = require('fs')// 注册页面router.get('/signup', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signup', &#123; session: ctx.session, &#125;)&#125;)// post 注册router.post('/signup', async(ctx, next) =&gt; &#123; //console.log(ctx.request.body) let user = &#123; name: ctx.request.body.name, pass: ctx.request.body.password, repeatpass: ctx.request.body.repeatpass, avator: ctx.request.body.avator &#125; await userModel.findDataByName(user.name) .then(async (result) =&gt; &#123; console.log(result) if (result.length) &#123; try &#123; throw Error('用户已经存在') &#125; catch (error) &#123; //处理err console.log(error) &#125; // 用户存在 ctx.body = &#123; data: 1 &#125;;; &#125; else if (user.pass !== user.repeatpass || user.pass === '') &#123; ctx.body = &#123; data: 2 &#125;; &#125; else &#123; // ctx.session.user=ctx.request.body.name let base64Data = user.avator.replace(/^data:image\/\w+;base64,/, ""); let dataBuffer = new Buffer(base64Data, 'base64'); let getName = Number(Math.random().toString().substr(3)).toString(36) + Date.now() await fs.writeFile('./public/images/' + getName + '.png', dataBuffer, err =&gt; &#123; if (err) throw err; console.log('头像上传成功') &#125;); await userModel.insertData([user.name, md5(user.pass), getName, moment().format('YYYY-MM-DD HH:mm:ss')]) .then(res=&gt;&#123; console.log('注册成功',res) //注册成功 ctx.body = &#123; data: 3 &#125;; &#125;) &#125; &#125;)&#125;)module.exports = router 我们使用md5实现密码加密，长度是32位的 使用我们之前说的bodyParse来解析提交的数据，通过ctx.request.body得到 我们引入了数据库的操作 findDataByName和insertData，因为之前我们在/lib/mysql.js中已经把他们写好，并暴露出来了。意思是先从数据库里面查找注册的用户名，如果找到了证明该用户名已经被注册过了，如果没有找到则使用insertData增加到数据库中 ctx.body 是我们通过ajax提交之后给页面返回的数据，比如提交ajax成功之后msg.data=1的时候就代表用户存在，msg.data出现在后面的signup.ejs模板ajax请求中 上传头像之前要新建好文件夹，我们ajax发送的是base64的格式，然后使用fs.writeFile来生成图片 我们使用ajax来提交数据，方便来做成功错误的处理 模板引擎ejs我们使用的是ejs，语法可以见ejs 之前我们写了这么一段代码12345router.get('/signup',async (ctx,next)=&gt;&#123; await ctx.render('signup',&#123; session:ctx.session, &#125;)&#125;) 这里就用到了ejs所需的session 我们通过渲染signup.ejs模板，将值ctx.session赋值给session，之后我们就可以在signup.ejs中使用了ejs的常用标签为： &lt;% code %&gt;：运行 JavaScript 代码，不输出 &lt;%= code %&gt;：显示转义后的 HTML内容 &lt;%- code %&gt;：显示原始 HTML 内容 &lt;%= code %&gt;和&lt;%- code %&gt;的区别在于，&lt;%= code %&gt;不管你写什么都会原样输出，比如code为 &lt;strong&gt;hello&lt;/strong&gt;的时候 &lt;%= code %&gt; 会显示&lt;strong&gt;hello&lt;/strong&gt;而&lt;%- code %&gt;则显示加粗的hello 实现登录页面 修改 /routers/signin.js12345678910111213const router = require('koa-router')();const userModel = require('../lib/mysql.js')const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginrouter.get('/signin', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signin', &#123; session: ctx.session, &#125;)&#125;)module.exports=router 修改 /views/signin.ejs 123456789101112131415&lt;%- include("header",&#123;type:'signin'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post "&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="密码" type="password" name="password"&gt; &lt;/div&gt; &lt;div class="submit"&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;% include footer %&gt; 修改 index.js 文件 把下面这段代码注释去掉，之前注释是因为我们没有写signin的路由，以免报错，后面还有文章页和登出页的路由，大家记住一下 1app.use(require('./routers/signin.js').routes()) 现在注册一下来看看效果吧1$ supervisor --harmony index 我们怎么查看我们注册好的账号和密码呢？打开mysql控制台 1$ select * from users; 这样刚刚我们注册的用户信息都出现了 如果你觉得这篇文章帮助到了你，那就赏脸给个star吧，https://github.com/wunci/Koa2-blog 登录页面修改signinrouters/signin.js123456789101112131415161718192021222324252627282930313233343536373839const router = require('koa-router')();const userModel = require('../lib/mysql.js')const md5 = require('md5')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLoginrouter.get('/signin', async(ctx, next) =&gt; &#123; await checkNotLogin(ctx) await ctx.render('signin', &#123; session: ctx.session, &#125;)&#125;)router.post('/signin', async(ctx, next) =&gt; &#123; console.log(ctx.request.body) let name = ctx.request.body.name; let pass = ctx.request.body.password; await userModel.findDataByName(name) .then(result =&gt; &#123; let res = result if (name === res[0]['name'] &amp;&amp; md5(pass) === res[0]['pass']) &#123; ctx.body = true ctx.session.user = res[0]['name'] ctx.session.id = res[0]['id'] console.log('ctx.session.id', ctx.session.id) console.log('session', ctx.session) console.log('登录成功') &#125;else&#123; ctx.body = false console.log('用户名或密码错误!') &#125; &#125;).catch(err =&gt; &#123; console.log(err) &#125;)&#125;)module.exports = router 我们进行登录操作，判断登录的用户名和密码是否有误，使用md5加密我们可以看到登录成功返回的结果是result 结果是这样的一个json数组：id：4 name：rrr pass：…[ RowDataPacket { id: 4, name: ‘rrr’, pass: ‘44f437ced647ec3f40fa0841041871cd’ } ] 修改views/signin.ejssignin.ejs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;%- include("header",&#123;type:'signin'&#125;) %&gt; &lt;div class="container"&gt; &lt;form class="form create" method="post "&gt; &lt;div&gt; &lt;label&gt;用户名：&lt;/label&gt; &lt;input placeholder="用户名" type="text" name="name"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;密码：&lt;/label&gt; &lt;input placeholder="密码" type="password" name="password"&gt; &lt;/div&gt; &lt;div class="submit"&gt;登录&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;script&gt; $(window).keyup(function(e)&#123; //console.log(e.keyCode) if (e.keyCode == 13) &#123; $('.submit').click() &#125; &#125;) $('.submit').click(()=&gt;&#123; if ($('input[name=name]').val().trim() == '' || $('input[name=password]').val().trim() == '' ) &#123; fade('请输入用户名或密码') &#125;else&#123; console.log($('.form').serialize()) $.ajax(&#123; url: "/signin", data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (!msg) &#123; $('input').val('') fade('用户名或密码错误') &#125; else&#123; fade('登录成功') setTimeout(()=&gt;&#123; window.location.href = "/posts" &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) &lt;/script&gt;&lt;% include footer %&gt; 我们增加了ajax请求，在routers/signin.js里，我们设置如果登录失败就返回false，登录成功返回true 12ctx.body = falsectx.body = true 那我们登录成功后要做跳转，可以看到window.location.href=&quot;/posts&quot;跳转到posts页面 全部文章修改routers/posts.js posts.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const router = require('koa-router')();const userModel = require('../lib/mysql.js')const moment = require('moment')const checkNotLogin = require('../middlewares/check.js').checkNotLoginconst checkLogin = require('../middlewares/check.js').checkLogin;const md = require('markdown-it')(); // 重置到文章页router.get('/', async(ctx, next) =&gt; &#123; ctx.redirect('/posts')&#125;)// 文章页router.get('/posts', async(ctx, next) =&gt; &#123; let res, postsLength, name = decodeURIComponent(ctx.request.querystring.split('=')[1]); if (ctx.request.querystring) &#123; console.log('ctx.request.querystring', name) await userModel.findDataByUser(name) .then(result =&gt; &#123; postsLength = result.length &#125;) await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) await ctx.render('selfPosts', &#123; session: ctx.session, posts: res, postsPageLength:Math.ceil(postsLength / 10), &#125;) &#125; else &#123; await userModel.findPostByPage(1) .then(result =&gt; &#123; //console.log(result) res = result &#125;) await userModel.findAllPost() .then(result=&gt;&#123; postsLength = result.length &#125;) await ctx.render('posts', &#123; session: ctx.session, posts: res, postsLength: postsLength, postsPageLength: Math.ceil(postsLength / 10), &#125;) &#125;&#125;)// 首页分页，每次输出10条router.post('/posts/page', async(ctx, next) =&gt; &#123; let page = ctx.request.body.page; await userModel.findPostByPage(page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;)// 个人文章分页，每次输出10条router.post('/posts/self/page', async(ctx, next) =&gt; &#123; let data = ctx.request.body await userModel.findPostByUserPage(data.name,data.page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;)module.exports = router 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉 修改 views/posts.ejs 12345&lt;%- include(&quot;header&quot;,&#123;type:&apos;posts&apos;&#125;) %&gt; posts&lt;% include footer %&gt; 现在看看登录成功之后的页面吧 接下来我们实现登出页面 登出页面修改 router/signout.js signout.js123456789const router = require('koa-router')();router.get('/signout', async(ctx, next) =&gt; &#123; ctx.session = null; console.log('登出成功') ctx.body = true&#125;)module.exports = router 把session设置为null即可 修改 index.js app.use(require(‘./routers/posts.js’).routes())的注释去掉，现在把注释的路由全部取消注释就对了 然后我们看看 views/header.ejs 我们点击登出后的ajax 的提交，成功之后回到posts页面 发表文章修改router/posts在后面增加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 发表文章页面router.get('/create', async(ctx, next) =&gt; &#123; await ctx.render('create', &#123; session: ctx.session, &#125;)&#125;)// post 发表文章router.post('/create', async(ctx, next) =&gt; &#123; let title = ctx.request.body.title, content = ctx.request.body.content, id = ctx.session.id, name = ctx.session.user, time = moment().format('YYYY-MM-DD HH:mm:ss'), avator, // 现在使用markdown不需要单独转义 newContent = content.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;), newTitle = title.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;); //console.log([name, newTitle, content, id, time]) await userModel.findUserData(ctx.session.user) .then(res =&gt; &#123; console.log(res[0]['avator']) avator = res[0]['avator'] &#125;) await userModel.insertPost([name, newTitle, md.render(content), content, id, time,avator]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;) 修改 views/create.ejs create.ejs123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%- include("header",&#123;type:'create'&#125;) %&gt;&lt;div class="container"&gt; &lt;form style="width:100%" method="post" class="form create"&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder="请输入标题" type="text" name="title"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea placeholder="请输入内容" name="content" id="" cols="42" rows="10"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="submit"&gt;发表&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $('.submit').click(()=&gt;&#123; if ($('input[name=title]').val().trim() == '') &#123; fade('请输入标题') &#125;else if ($('textarea').val().trim() == '') &#123; fade('请输入内容') &#125;else&#123; $.ajax(&#123; url: "/create", data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('发表成功') setTimeout(()=&gt;&#123; window.location.href="/posts" &#125;,1000) &#125;else&#123; fade('发表失败') &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在看看能不能发表吧 即使我们发表了文章，但是当前我们的posts的页面没有显示，因为还没有获取到数据 我们可以看我们之前写的代码 router.get(&#39;/posts&#39;, async(ctx, next) =&gt; {}路由1234567891011121314151617181920if (ctx.request.querystring) &#123; ...&#125;else &#123; await userModel.findPostByPage(1) .then(result =&gt; &#123; //console.log(result) res = result &#125;) await userModel.findAllPost() .then(result=&gt;&#123; postsLength = result.length &#125;) await ctx.render('posts', &#123; session: ctx.session, posts: res, postsLength: postsLength, postsPageLength: Math.ceil(postsLength / 10), &#125;) &#125; if前面这部分我们先不用管，后面会说。只需要看else后面的代码我们通过userModel.findPostByPage(1)来获取第一页的数据，然后查找所有文章的数量，最后除以10拿到首页文章的页数，把数据postsPageLength的值传给模板posts.ejs。这样就可以渲染出来了 修改 views/posts.ejs posts.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;%- include("header",&#123;type:'all'&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts"&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= res.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= res.name %&gt; "&gt;author: &lt;%= res.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= res.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= res.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= res.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= res.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="images/&lt;%= res.avator %&gt;.png"&gt; &lt;%= res.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- res.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://wunci.github.io/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; pagination(&#123; selector: '#page', totalPage: &lt;%= postsPageLength %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage: true, count: 2//当前页前后显示的数量 &#125;,function(val)&#123; // 当前页 $.ajax(&#123; url: "posts/page", type: 'POST', data:&#123; page: val &#125;, cache: false, success: function (msg) &#123; console.log(msg) if (msg != 'error') &#123; $('.posts').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) $('.posts').append( '&lt;li&gt;'+ '&lt;div class=\"author\"&gt;'+ '&lt;span title=\"'+ val.name +'\"&gt;&lt;a href=\"/posts?author='+ val.name +' \"&gt;author: '+ val.name +'&lt;/a&gt;&lt;/span&gt;'+ '&lt;span&gt;评论数：'+ val.comments +'&lt;/span&gt;'+ '&lt;span&gt;浏览量：'+ val.pv +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;div class=\"comment_pv\"&gt;'+ '&lt;span&gt;'+ val.moment +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;a href=\"/posts/'+ val.id +'\"&gt;'+ '&lt;div class=\"title\"&gt;'+ '&lt;img class="userAvator" src="images/'+ val.avator +'.png"&gt;'+ val.title + '&lt;/div&gt;'+ '&lt;div class=\"content\"&gt;'+ val.content + '&lt;/div&gt;'+ '&lt;/a&gt;'+ '&lt;/li&gt;' ) &#125;) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 现在看看posts页面有没有文章出现了 我们看到是所第一页的文章数据，初始化的稍后我们是用服务端渲染的数据，使用了分页，每页显示10条数据，然后通过请求页数。下面是服务端请求拿到的第一页的数据1234await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) 要拿到别的页面数据的话要向服务器发送post请求，如下1234567891011// 首页分页，每次输出10条router.post(&apos;/posts/page&apos;, async(ctx, next) =&gt; &#123; let page = ctx.request.body.page; await userModel.findPostByPage(page) .then(result=&gt;&#123; //console.log(result) ctx.body = result &#125;).catch(()=&gt;&#123; ctx.body = &apos;error&apos; &#125;) &#125;) 单篇文章页面但是我需要点击单篇文章的时候，显示一篇文章怎么办呢？ 修改 routers/posts.js 在posts.js后面增加 12345678910111213141516171819202122232425262728293031323334// 单篇文章页router.get('/posts/:postId', async(ctx, next) =&gt; &#123; let comment_res, res, pageOne, res_pv; await userModel.findDataById(ctx.params.postId) .then(result =&gt; &#123; //console.log(result ) res = result res_pv = parseInt(result[0]['pv']) res_pv += 1 // console.log(res_pv) &#125;) await userModel.updatePostPv([res_pv, ctx.params.postId]) await userModel.findCommentByPage(1,ctx.params.postId) .then(result =&gt; &#123; pageOne = result //console.log('comment', comment_res) &#125;) await userModel.findCommentById(ctx.params.postId) .then(result =&gt; &#123; comment_res = result //console.log('comment', comment_res) &#125;) await ctx.render('sPost', &#123; session: ctx.session, posts: res[0], commentLenght: comment_res.length, commentPageLenght: Math.ceil(comment_res.length/10), pageOne:pageOne &#125;)&#125;) 现在的设计是，我们点进去出现的url是 /posts/1 这类的 1代表该篇文章的id，我们在数据库建表的时候就处理了，让id为主键，然后递增 我们通过userModel.findDataById 文章的id来查找数据库我们通过userModel.findCommentById 文章的id来查找文章的评论，因为单篇文章里面有评论的功能最后通过sPost.ejs模板渲染单篇文章 修改 views/sPost.ejs sPost.ejs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186&lt;%- include("header",&#123;type:''&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts spost"&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= posts.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= posts.name %&gt; "&gt;author: &lt;%= posts.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= posts.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= posts.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= posts.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= posts.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="../images/&lt;%= posts.avator %&gt;.png"&gt; &lt;%= posts.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- posts.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;div class="edit"&gt; &lt;% if(session &amp;&amp; session.user === posts.name )&#123; %&gt; &lt;p&gt;&lt;a href="&lt;%= posts['id'] %&gt;/edit"&gt;编辑&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a class="delete_post"&gt;删除&lt;/a&gt;&lt;/p&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="comment_wrap"&gt; &lt;% if(session.user)&#123; %&gt; &lt;form class="form" method="post" action="/&lt;%= posts.id %&gt;"&gt; &lt;textarea id="spContent" name="content" cols="82"&gt;&lt;/textarea&gt; &lt;div class="submit"&gt;发表留言&lt;/div&gt; &lt;/form&gt; &lt;% &#125; else&#123; %&gt; &lt;p class="tips"&gt;登录之后才可以评论哟&lt;/p&gt; &lt;% &#125; %&gt; &lt;% if (commentPageLenght &gt; 0) &#123; %&gt; &lt;div class="comment_list markdown"&gt; &lt;% pageOne.forEach(function(res)&#123; %&gt; &lt;div class="cmt_lists"&gt; &lt;div class="cmt_content"&gt; &lt;div class="userMsg"&gt; &lt;img src="../images/&lt;%= res['avator'] %&gt;.png" alt=""&gt;&lt;span&gt;&lt;%= res['name'] %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="cmt_detail"&gt; &lt;%- res['content'] %&gt; &lt;/div&gt; &lt;span class="cmt_time"&gt;&lt;%= res['moment'] %&gt;&lt;/span&gt; &lt;span class="cmt_name"&gt; &lt;% if(session &amp;&amp; session.user === res['name'])&#123; %&gt; &lt;a class="delete_comment" href="javascript:delete_comment(&lt;%= res['id'] %&gt;);"&gt; 删除&lt;/a&gt; &lt;% &#125; %&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125;) %&gt; &lt;/div&gt; &lt;% &#125; else&#123; %&gt; &lt;p class="tips"&gt;还没有评论，赶快去评论吧！&lt;/p&gt; &lt;% &#125; %&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://wunci.github.io/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; var userName = "&lt;%- session.user %&gt;" pagination(&#123; selector: '#page', totalPage: &lt;%= commentPageLenght %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage:true, count: 2//当前页前面显示的数量 &#125;,function(val)&#123; // 当前页 var _comment = '' $.ajax(&#123; url: "&lt;%= posts.id %&gt;/commentPage", type: 'POST', data:&#123; page: val &#125;, cache: false, success: function (msg) &#123; //console.log(msg) _comment = '' if (msg != 'error') &#123; $('.comment_list').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) _comment += '&lt;div class=\"cmt_lists\"&gt;&lt;div class=\"cmt_content\"&gt;&lt;div class=\"userMsg\"&gt;&lt;img src = \"../images/'+ val.avator +'.png\" &gt;&lt;span&gt;'+ val.name +'&lt;/span&gt;&lt;/div &gt;&lt;div class="cmt_detail"&gt;'+ val.content + '&lt;/div&gt;&lt;span class=\"cmt_time\"&gt;'+ val.moment +'&lt;/span&gt;&lt;span class=\"cmt_name\"&gt;'; if (val.name == userName) &#123; _comment += '&lt;a class=\"delete_comment\" href=\"javascript:delete_comment('+ val.id +');\"&gt; 删除&lt;/a&gt;' &#125; _comment += '&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;' &#125;) $('.comment_list').append(_comment) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) // 删除文章 $('.delete_post').click(() =&gt; &#123; $.ajax(&#123; url: "&lt;%= posts.id %&gt;/remove", type: 'POST', cache: false, success: function (msg) &#123; if (msg.data == 1) &#123; fade('删除文章成功') setTimeout(() =&gt; &#123; window.location.href = "/posts" &#125;, 1000) &#125; else if (msg.data == 2) &#123; fade('删除文章失败'); setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1000) &#125; &#125; &#125;) &#125;) // 评论 var isAllow = true $('.submit').click(function()&#123; if (!isAllow) return isAllow = false if ($('textarea').val().trim() == '') &#123; fade('请输入评论！') &#125;else&#123; $.ajax(&#123; url: '/' + location.pathname.split('/')[2], data:$('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('发表留言成功') setTimeout(()=&gt;&#123; isAllow = true window.location.reload() &#125;,1500) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125; &#125;) // 删除评论 function delete_comment(id) &#123; $.ajax(&#123; url: "&lt;%= posts.id %&gt;/comment/" + id + "/remove", type: 'POST', cache: false, success: function (msg) &#123; if (msg.data == 1) &#123; fade('删除留言成功') setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1000) &#125; else if (msg.data == 2) &#123; fade('删除留言失败'); setTimeout(() =&gt; &#123; window.location.reload() &#125;, 1500) &#125; &#125;, error: function () &#123; alert('异常') &#125; &#125;) &#125; &lt;/script&gt;&lt;% include footer %&gt; 现在点击单篇文章试试，进入单篇文章页面，但是编辑、删除、评论都还没有做，点击无效，我们先不做，先实现每个用户自己发表的文章列表，我们之前在 get ‘/posts’ 里面说先忽略if (ctx.request.querystring) {}里面的代码，这里是做了一个处理，假如用户点击了某个用户，该用户发表了几篇文章，我们需要只显示该用户发表的文章，那么进入的url应该是 /posts?author=xxx ,这个处理在posts.ejs 就已经加上了，就在文章的左下角，作者：xxx就是一个链接。我们通过判断用户来查找文章，继而有了ctx.request.querystring 获取到的是：author=xxx 注：这里我们处理了，通过判断 session.user === res[&#39;name&#39;] 如果不是该用户发的文章，不能编辑和删除，评论也是。这里面也可以注意一下包裹的&lt;a href=&quot;&quot;&gt;&lt;/a&gt;标签 个人已发表文章列表里面还记得之前在 get ‘/post’ 里面的代码吗？下面的代码就是之前说先不处理的代码片段，不过这个不用再次添加，之前已经添加好了，这段代码处理个人发布的文章列表，我们是通过selfPosts.ejs模板来渲染的，样式和全部文章列表一样，但是牵扯到分页的问题，分页请求的是不同的接口地址 12345678910111213141516if (ctx.request.querystring) &#123; console.log('ctx.request.querystring', name) await userModel.findDataByUser(name) .then(result =&gt; &#123; postsLength = result.length &#125;) await userModel.findPostByUserPage(name,1) .then(result =&gt; &#123; res = result &#125;) await ctx.render('selfPosts', &#123; session: ctx.session, posts: res, postsPageLength:Math.ceil(postsLength / 10), &#125;) &#125; 修改 selfPost.ejs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;%- include("header",&#123;type:'my'&#125;) %&gt; &lt;div class="container"&gt; &lt;ul class="posts"&gt; &lt;% posts.forEach(function(res)&#123; %&gt; &lt;li&gt; &lt;div class="author"&gt; &lt;span title="&lt;%= res.name %&gt;"&gt;&lt;a href="/posts?author=&lt;%= res.name %&gt; "&gt;author: &lt;%= res.name %&gt;&lt;/a&gt;&lt;/span&gt; &lt;span&gt;评论数：&lt;%= res.comments %&gt;&lt;/span&gt; &lt;span&gt;浏览量：&lt;%= res.pv %&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="comment_pv"&gt; &lt;span&gt;&lt;%= res.moment %&gt;&lt;/span&gt; &lt;/div&gt; &lt;a href="/posts/&lt;%= res.id %&gt;"&gt; &lt;div class="title"&gt; &lt;img class="userAvator" src="images/&lt;%= res.avator %&gt;.png"&gt; &lt;%= res.title %&gt; &lt;/div&gt; &lt;div class="content markdown"&gt; &lt;%- res.content %&gt; &lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125;) %&gt; &lt;/ul&gt; &lt;div style="margin-top: 30px" class="pagination" id="page"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script src="http://wunci.github.io/pagination/pagination.js"&gt;&lt;/script&gt; &lt;script&gt; pagination(&#123; selector: '#page', totalPage: &lt;%= postsPageLength %&gt;, currentPage: 1, prev: '上一页', next: '下一页', first: true, last: true, showTotalPage: true, count: 2//当前页前后显示的数量 &#125;,function(val)&#123; // 当前页 $.ajax(&#123; url: "posts/self/page", type: 'POST', data:&#123; page: val, name: location.search.slice(1).split('=')[1] &#125;, cache: false, success: function (msg) &#123; //console.log(msg) if (msg != 'error') &#123; $('.posts').html(' ') $.each(msg,function(i,val)&#123; //console.log(val.content) $('.posts').append( '&lt;li&gt;'+ '&lt;div class=\"author\"&gt;'+ '&lt;span title=\"'+ val.name +'\"&gt;&lt;a href=\"/posts?author='+ val.name +' \"&gt;author: '+ val.name +'&lt;/a&gt;&lt;/span&gt;'+ '&lt;span&gt;评论数：'+ val.comments +'&lt;/span&gt;'+ '&lt;span&gt;浏览量：'+ val.pv +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;div class=\"comment_pv\"&gt;'+ '&lt;span&gt;'+ val.moment +'&lt;/span&gt;'+ '&lt;/div&gt;'+ '&lt;a href=\"/posts/'+ val.id +'\"&gt;'+ '&lt;div class=\"title\"&gt;'+ '&lt;img class="userAvator" src="images/' + val.avator + '.png"&gt;' + val.title + '&lt;/div&gt;'+ '&lt;div class=\"content\"&gt;'+ val.content + '&lt;/div&gt;'+ '&lt;/a&gt;'+ '&lt;/li&gt;' ) &#125;) &#125;else&#123; alert('分页不存在') &#125; &#125; &#125;) &#125;) &lt;/script&gt;&lt;% include footer %&gt; 编辑文章、删除文章、评论、删除评论 评论 修改routers/posts.js 在post.js 后面增加 12345678910111213141516171819202122232425262728293031323334353637// 发表评论router.post('/:postId', async(ctx, next) =&gt; &#123; let name = ctx.session.user, content = ctx.request.body.content, postId = ctx.params.postId, res_comments, time = moment().format('YYYY-MM-DD HH:mm:ss'), avator; await userModel.findUserData(ctx.session.user) .then(res =&gt; &#123; console.log(res[0]['avator']) avator = res[0]['avator'] &#125;) await userModel.insertComment([name, md.render(content),time, postId,avator]) await userModel.findDataById(postId) .then(result =&gt; &#123; res_comments = parseInt(result[0]['comments']) res_comments += 1 &#125;) await userModel.updatePostComment([res_comments, postId]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;)// 评论分页router.post('/posts/:postId/commentPage', async function(ctx)&#123; let postId = ctx.params.postId, page = ctx.request.body.page; await userModel.findCommentByPage(page,postId) .then(res=&gt;&#123; ctx.body = res &#125;).catch(()=&gt;&#123; ctx.body = 'error' &#125;) &#125;) 现在试试发表评论的功能吧，之所以这样简单，因为我们之前就在sPost.ejs做了好几个ajax的处理，删除文章和评论也是如此评论我们也做了分页，所以后面会有一个评论的分页的接口，我们已经在sPost.ejs里面写好了ajax请求 删除评论 修改routers/posts.js 继续在post.js 后面增加 12345678910111213141516171819202122232425// 删除评论router.post('/posts/:postId/comment/:commentId/remove', async(ctx, next) =&gt; &#123; let postId = ctx.params.postId, commentId = ctx.params.commentId, res_comments; await userModel.findDataById(postId) .then(result =&gt; &#123; res_comments = parseInt(result[0]['comments']) //console.log('res', res_comments) res_comments -= 1 //console.log(res_comments) &#125;) await userModel.updatePostComment([res_comments, postId]) await userModel.deleteComment(commentId) .then(() =&gt; &#123; ctx.body = &#123; data: 1 &#125; &#125;).catch(() =&gt; &#123; ctx.body = &#123; data: 2 &#125; &#125;)&#125;) 现在试试删除评论的功能吧 删除文章 只有自己发表的文字删除的文字才会显示出来，才能被删除， 修改routers/posts.js 继续在post.js 后面增加 123456789101112131415// 删除单篇文章router.post('/posts/:postId/remove', async(ctx, next) =&gt; &#123; let postId = ctx.params.postId await userModel.deleteAllPostComment(postId) await userModel.deletePost(postId) .then(() =&gt; &#123; ctx.body = &#123; data: 1 &#125; &#125;).catch(() =&gt; &#123; ctx.body = &#123; data: 2 &#125; &#125;)&#125;) 现在试试删除文章的功能吧 编辑文章 修改routers/posts.js 继续在post.js 后面增加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 编辑单篇文章页面router.get('/posts/:postId/edit', async(ctx, next) =&gt; &#123; let name = ctx.session.user, postId = ctx.params.postId, res; await userModel.findDataById(postId) .then(result =&gt; &#123; res = result[0] //console.log('修改文章', res) &#125;) await ctx.render('edit', &#123; session: ctx.session, postsContent: res.md, postsTitle: res.title &#125;)&#125;)// post 编辑单篇文章router.post('/posts/:postId/edit', async(ctx, next) =&gt; &#123; let title = ctx.request.body.title, content = ctx.request.body.content, id = ctx.session.id, postId = ctx.params.postId, // 现在使用markdown不需要单独转义 newTitle = title.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;), newContent = content.replace(/[&lt;"&gt;']/g, (target) =&gt; &#123; return &#123; '&lt;': '&amp;lt;', '"': '&amp;quot;', '&gt;': '&amp;gt;', "'": '&amp;#39;' &#125;[target] &#125;); await userModel.updatePost([newTitle, md.render(content), content, postId]) .then(() =&gt; &#123; ctx.body = true &#125;).catch(() =&gt; &#123; ctx.body = false &#125;)&#125;) 修改views/edit.js 12345678910111213141516171819202122232425262728293031323334353637&lt;%- include("header",&#123;type:''&#125;) %&gt;&lt;div class="container"&gt; &lt;form style="width:100%" class="form create" method="post"&gt; &lt;div&gt; &lt;label&gt;标题：&lt;/label&gt; &lt;input placeholder="标题" type="text" name="title" value="&lt;%- postsTitle %&gt;"&gt; &lt;/div&gt; &lt;div&gt; &lt;label&gt;内容：&lt;/label&gt; &lt;textarea name="content" id="" cols="42" rows="10"&gt;&lt;%= postsContent %&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="submit"&gt;修改&lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;script&gt; $('.submit').click(()=&gt;&#123; $.ajax(&#123; url: '', data: $('.form').serialize(), type: "POST", cache: false, dataType: 'json', success: function (msg) &#123; if (msg) &#123; fade('修改成功') setTimeout(()=&gt;&#123; window.location.href="/posts" &#125;,1000) &#125; &#125;, error: function () &#123; alert('异常'); &#125; &#125;) &#125;)&lt;/script&gt;&lt;% include footer %&gt; 现在试试编辑文字然后修改提交吧 结语至此一个简单的blog就已经制作好了，其他扩展功能相信你已经会了吧！如果出现问题，还望积极提问哈，我会尽快处理的 所有的代码都在 https://github.com/wunci/Koa2-blog 里面，如果觉得不错就star一下吧。有问题可以提问哟下一篇可能是 Node + express + mongoose 或 zepto源码系列感谢您的阅读^_^ 个人小程序]]></content>
      <categories>
        <category>javascript</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Mysql</tag>
        <tag>javascript</tag>
        <tag>Koa</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读zepto源码，封装自己的zepto库（一）]]></title>
    <url>%2F2017%2F06%2F29%2F%E8%AF%BBzepto%E6%BA%90%E7%A0%81%EF%BC%8C%E5%B0%81%E8%A3%85%E8%87%AA%E5%B7%B1%E7%9A%84zepto%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面 读zepto源码，封装自己的zepto库系列是自己在读zepto源码的一些理解，有错误的地方还望指出。如果觉得本系列对你有所帮助，还请持续关注wunci，谢谢。 zepto的整体架构首先来看看整体代码结构 123456789101112131415161718192021222324252627282930313233(function()&#123; var wunci = &#123;&#125;,$ $ = function(selector)&#123; return wunci.init(selector) &#125; wunci.init = function(selector)&#123; var dom; dom = document.querySelectorAll(selector); return wunci.Z(dom,selector) &#125; wunci.Z = function(dom,selector)&#123; return new Z(dom,selector) &#125; wunci.Z.prototype = Z.prototype = &#123; test:function()&#123; alert(1) &#125; &#125; function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length &#125; window.$ = window.wunci = $&#125;)() 首先我们设置了一个闭包，避免产生全局变量123(function()&#123; ...&#125;)() 我们定义一个对象wunci和$，以便后面使用 1var wunci = &#123;&#125;,$ $函数返回了wunci.init(selector),我们知道使用zepto的时候，一般是$(‘p’)，而selector就是p元素，当然不止这一种情况如$(function(){}),所以对选择器后面我们要做判断123$ = function(selector)&#123; return wunci.init(selector)&#125; 而wunci.init首先定义了一个dom，通过选择器选取的元素赋值给dom，最后返回wunci.init，传入dom和选择元素selector 12345wunci.init = function(selector)&#123; var dom; dom = document.querySelector(selector); return wunci.Z(dom,selector)&#125; 我们可以看到之前我们定义了对象wunci，而后我们就往里面添加了一些方法，就像： 12345678910wunci = &#123; init：function(selector)&#123; var dom; dom = document.querySelector(selector); return wunci.Z(dom,selector) &#125;, Z: function(dom,selector)&#123; return new Z(dom,selector) &#125;&#125; 通过wunci.Z，如果有看过zepto源码的同学应该对此有了解.每次用$调用的时候,将直接返回一个Z的实例.达到无new调用的效果,$(‘p’)返回一个实例，然后$(‘p’).test()调用他的原形方法，这里的方法是test 1234567891011wunci.Z = function(dom,selector)&#123; return new Z(dom,selector)&#125;function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 由于我们是return new Z(dom,selector),那自然,我们需要手动的把wunci.Z的prototype指向Z的prototype 123456789wunci.Z.prototype = Z.prototype&#123;&#125;我们可以在里面添加方法了，如addClass eq等，我们试试加一个testwunci.Z.prototype = Z.prototype&#123; test: function()&#123; console.log('test') &#125;&#125; Z函数是这样的，因为我们选择器选择的元素是一个数组（其实不是）我们把this指向选择的元素，然后添加两个元素selector和length，分别代表选择的元素名和元素的长度 1234567function Z(dom,selector) &#123; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i] &#125; this.selector = selector; this.length = dom.length&#125; 最后我们在window上对外暴露一个接口,我们就可以用 $(‘p’) 或者wunci(‘p’) 即可调用. 1window.$ = window.wunci = $ 现在可以试试能不能运行 123html：&lt;p&gt;test&lt;/p&gt;js：$('p') 调用方法试试 $('p').test() 我们的zepto已经完成了，是不是很简单？骗你的，还差得远呢，后面会慢慢完善。待续。。。如果你觉得该文章帮助到了你，不妨star一下https://github.com/wunci/wunci.github.io ，感谢]]></content>
      <tags>
        <tag>原创</tag>
        <tag>javascript</tag>
        <tag>zepto</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas仿微信红包照片]]></title>
    <url>%2F2017%2F06%2F28%2Fcanvas%E5%BE%AE%E4%BF%A1%E7%BA%A2%E5%8C%85%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[canvas仿微信红包照片 By wunciHTML1&lt;canvas id=&quot;cav&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt; CSS 设置canvas的背景图 1234canvas&#123; background:url(https://b-ssl.duitang.com/uploads/item/201501/22/20150122203239_Cfr58.thumb.700_0.jpeg) no-repeat; background-size:100% 100%;&#125; JS12345678910111213141516171819202122232425262728293031323334353637var canvas = document.querySelector("#cav")var context = canvas.getContext("2d");var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30)context.globalAlpha = 0.96;context.fillStyle = '#333'context.rect(0,0,canvas.width,canvas.height);context.fill();context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore();var num = 30;var time = null;document.body.onclick = function()&#123; function circle()&#123; num += 5 context.save() context.beginPath() context.arc(randomX,randomY,num,0,Math.PI*2,false); context.clip(); context.clearRect(0,0,canvas.width,canvas.height) context.restore(); console.log(num) if (num &gt;= 677)&#123; clearInterval(timer) &#125; &#125; timer = setInterval(circle,10)&#125; 解析 随机出现圆心的位置，因为canvas为500*500 圆心为30 所以圆心的范围为 X(30,470) Y(470,30) 12var randomX = Math.floor(Math.random()*440+30)var randomY = Math.floor(Math.random()*440+30) 绘制矩形 透明度为0.96 填充颜色#333 宽高为canvas的宽高 最后用fill填充 1234context.globalAlpha = 0.96;context.fillStyle = '#333'context.rect(0,0,canvas.width,canvas.height);context.fill(); 初始化圆心的位置，用arc绘制圆，默认半径为30，用clip剪切，只有被剪切区域内是可见的 123456context.save()context.beginPath()context.arc(randomX,randomY,30,0,Math.PI*2,false);context.clip();context.clearRect(0,0,canvas.width,canvas.height)context.restore(); 点击body的时候，设置定时器，让圆的半径每隔10毫秒增加5，当num半径大于677关闭定时器，677为canvas对角的长度 1document.body.onclick = function()&#123;&#125; 效果预览]]></content>
      <categories>
        <category>javascript</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp基础教程]]></title>
    <url>%2F2017%2F06%2F27%2Fgulp%2F</url>
    <content type="text"><![CDATA[入门指南–引用gulp官网示例 全局安装 gulp： 1$ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： 1$ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： 12345var gulp = require('gulp');gulp.task('default', function() &#123; // 将你的默认的任务代码放在这&#125;); 运行 gulp 1$ gulp //默认的名为 default 的任务（task）将会被运行，在这里，这个任务并未做任何事情。 至此，一个简单的gulp已经完成，接下来让我们来完善部分功能 gulp功能完善生成package.json文件1$ npm init //一直回车，有需要的可以设置 安装所需包 使用淘宝镜像 12$ npm install -g cnpm --registry=https://registry.npm.taobao.org示例 $ cnpm install [name] 接着1$ cnpm i browser-sync gulp gulp-clean-css gulp-imagemin gulp-rename gulp-sass gulp-uglify gulp.spritesmith gulp-autoprefixer --save 新建gulpfile.js文件添加123456789var gulp = require('gulp'); var browserSync = require('browser-sync').create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require('gulp-sass'); //sass转cssvar reload = browserSync.reload; var minifyCSS = require('gulp-clean-css') //css压缩var uglify = require('gulp-uglify') //js压缩var imagemin = require('gulp-imagemin') //图片压缩var rename = require('gulp-rename') //文件重命名var autoprefixer = require('gulp-autoprefixer') //自动添加前缀 设置默认文件地址12345678code为文件夹，里面存放html css js文件var src = &#123; scss: 'code/scss/*.scss', css: 'code/css/*.css', html: 'code/*.html', js: 'code/js/*.js', images: 'code/images/*.&#123;png,jpg,gif,ico&#125;'&#125;; gulp.task(name[, deps], fn)1234567891011121314151617name: 任务的名字deps: 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。fn: 该函数定义任务所要执行的一些操作。通常来说，它会是这种形式：gulp.src().pipe(someplugin())。// 静态服务器 + 监听 scss/html 文件 gulp.task('serve', ['sass'], function() &#123; browserSync.init(&#123; server: "./code" &#125;); gulp.watch(src.scss, ['sass']); gulp.watch(src.css, ['css']); gulp.watch(src.images, ['images']) gulp.watch(src.js, ['js']); gulp.watch(src.html).on('change', reload);&#125;); scss编译后的css将注入到浏览器里实现更新123456789101112131415gulp.task('sass', function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7',//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;); 雪碧图（有需要可以尝试）123456789101112var spritesmith = require('gulp.spritesmith'); gulp.task('sprite', function () &#123; return gulp.src('code/images/*.png') .pipe(spritesmith(&#123; imgName:'images/sprite20161010.png', //保存合并后图片的地址 cssName:'css/sprite.css', //保存合并后对于css样式的地址 padding:20, algorithm:'binary-tree', &#125;)) .pipe(gulp.dest('code/scss')); &#125;); 监听css文件1234567gulp.task('css', function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;); 监听js文件12345678910gulp.task('js', function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: '.min'&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest('code/dest')) .pipe(reload(&#123;stream: true&#125;));&#125;) 压缩图片任务12345678910// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest('images')) .pipe(reload(&#123;stream: true&#125;));&#125;); 最后控制台输入gulp执行1gulp.task('default', ['serve']); 如果觉得帮助到了你，欢迎star -&gt; https://github.com/wunci/wunci.github.io 完整代码文件目录123456789101112-code -imgage 1.png -css default.css -scss default.scss -js default.js index.htmlgulpfile.jspackage.json package.json12345678910111213141516171819202122232425&#123; "name": "gulp-test", "version": "1.0.0", "description": "Gulp &amp; SASS", "main": "gulpfile.js", "scripts": &#123; "start": "gulp" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "browser-sync": "^2.2.0", "gulp": "^3.9.1", "gulp-clean-css": "^3.0.3", "gulp-imagemin": "^3.1.1", "gulp-rename": "^1.2.2", "gulp-sass": "^3.1.0", "gulp-uglify": "^2.0.1", "gulp.spritesmith": "^6.4.0", "gulp-autoprefixer": "^4.0.0" &#125;, "dependencies": &#123; &#125;&#125; gulpfile.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103var gulp = require('gulp'); var browserSync = require('browser-sync').create(); //通过流的方式创建任务流程, 这样您就可以在您的任务完成后调用reload，所有的浏览器将被告知的变化并实时更新var sass = require('gulp-sass'); //sass转cssvar reload = browserSync.reload; var minifyCSS = require('gulp-clean-css') //css压缩var uglify = require('gulp-uglify') //js压缩var imagemin = require('gulp-imagemin') //图片压缩var rename = require('gulp-rename') //文件重命名var autoprefixer = require('gulp-autoprefixer') //自动添加前缀var src = &#123; scss: 'code/scss/*.scss', css: 'code/css/*.css', html: 'code/*.html', js: 'code/js/*.js', images: 'code/images/*.&#123;png,jpg,gif,ico&#125;'&#125;;// 静态服务器 + 监听 scss/html 文件 gulp.task('serve', ['sass'], function() &#123; browserSync.init(&#123; server: "./code" &#125;); gulp.watch(src.scss, ['sass']); gulp.watch(src.css, ['css']); gulp.watch(src.images, ['images']) gulp.watch(src.js, ['js']); gulp.watch(src.html).on('change', reload);&#125;);// scss编译后的css将注入到浏览器里实现更新gulp.task('sass', function() &#123; return gulp.src(src.scss) .pipe(sass()) .pipe(minifyCSS(&#123; advanced: false,//类型：Boolean 默认：true [是否开启高级优化（合并选择器等）] compatibility: 'ie7',//保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式] keepBreaks: true,//类型：Boolean 默认：false [是否保留换行] keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀 &#125;)) .pipe(autoprefixer()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) //重新输出数据到某个文件夹，如果没有就会自动创建 .pipe(reload(&#123;stream: true&#125;));&#125;);// 雪碧图（有需要可以尝试）//var spritesmith = require('gulp.spritesmith'); // gulp.task('sprite', function () &#123;// return gulp.src('code/images/*.png')// .pipe(spritesmith(&#123;// imgName:'images/sprite20161010.png', //保存合并后图片的地址// cssName:'css/sprite.css', //保存合并后对于css样式的地址// padding:20,// algorithm:'binary-tree',// &#125;))// .pipe(gulp.dest('code/scss'));// &#125;);gulp.task('css', function() &#123; return gulp.src(src.css) .pipe(minifyCSS()) .pipe(rename(&#123;suffix: '.min'&#125;)) .pipe(gulp.dest("code/css")) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task('js', function() &#123; // 1. 找到文件 return gulp.src(src.js) //2. 压缩文件 .pipe(uglify()) .pipe(rename(&#123;suffix: '.min'&#125;)) //3. 另存压缩后的文件 .pipe(gulp.dest('code/dest')) .pipe(reload(&#123;stream: true&#125;));&#125;)// 压缩图片任务// 在命令行输入 gulp images 启动此任务gulp.task('images', function () &#123; // 1. 找到图片 gulp.src(src.images) // 2. 压缩图片 .pipe($.imagemin()) // 3. 另存图片 .pipe(gulp.dest('images')) .pipe(reload(&#123;stream: true&#125;));&#125;);gulp.task('default', ['serve']);]]></content>
      <categories>
        <category>javascript</category>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
</search>
